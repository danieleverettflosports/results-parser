<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Race Results Extractor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèÉ</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }
        
        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .input-section {
            margin-bottom: 20px;
        }
        
        .input-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }
        
        .input-area {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        .input-area:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .button-row {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #e0e0e0;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background: #38a169;
            transform: translateY(-2px);
        }
        
        .btn-warning {
            background: #ed8936;
            color: white;
        }
        
        .btn-warning:hover {
            background: #dd6b20;
        }
        
        .format-selector {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }
        
        .format-selector select {
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
        }
        
        .stats-bar {
            display: flex;
            gap: 30px;
            padding: 15px 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
        
        .stat-value {
            font-weight: 700;
            color: #333;
            font-size: 1.1em;
        }
        
        .table-container {
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .table-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .table-title {
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .table-wrapper {
            max-height: 600px;
            overflow-y: auto;
            overflow-x: auto;
        }
        
        .results-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }
        
        .results-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .results-table th {
            background: #f8f9fa;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #e0e0e0;
            white-space: nowrap;
        }
        
        .results-table tbody tr {
            transition: background-color 0.2s ease;
        }
        
        .results-table tbody tr:hover {
            background-color: #f8f9fa;
        }
        
        .results-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .results-table tbody tr:nth-child(even) {
            background-color: #fafbfc;
        }
        
        .place-cell {
            font-weight: 700;
            color: #667eea;
            text-align: center;
        }
        
        .place-cell.gold {
            color: #f6ad55;
        }
        
        .place-cell.silver {
            color: #a0aec0;
        }
        
        .place-cell.bronze {
            color: #ed8936;
        }

        .race-header-row {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .race-header {
            text-align: center;
            font-weight: 700;
            font-size: 1.1em;
            color: white;
            padding: 12px !important;
            letter-spacing: 0.5px;
        }

        .bib-cell {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #718096;
            text-align: center;
        }
        
        .name-cell {
            font-weight: 500;
            color: #2d3748;
        }
        
        .team-cell {
            color: #4a5568;
        }
        
        .time-cell {
            font-family: 'Monaco', 'Menlo', monospace;
            font-weight: 600;
            color: #2d3748;
        }
        
        .points-cell {
            text-align: center;
            font-weight: 600;
            color: #667eea;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #a0aec0;
        }
        
        .empty-state-icon {
            font-size: 3em;
            margin-bottom: 20px;
        }
        
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #48bb78;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            font-weight: 600;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .error-message {
            color: #e53e3e;
            background: #fff5f5;
            border: 1px solid #feb2b2;
            padding: 10px 15px;
            border-radius: 6px;
            margin-top: 10px;
            display: none;
        }
        
        .hidden {
            display: none;
        }
        
        .table-wrapper::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        .table-wrapper::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .table-wrapper::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 5px;
        }
        
        .table-wrapper::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Race Results Extractor</h1>
            <p>Transform messy race results into beautiful, organized data - supports KarmaRush, RunSignup, MileSplit, and RunHigh</p>
        </header>

        <div class="control-panel">
            <div class="input-section">
                <label class="input-label">Paste Race Results Here</label>
                <textarea id="input" class="input-area" placeholder="Copy and paste race results from KarmaRush, RunSignup, MileSplit, or RunHigh...

RunHigh Example:
  509     2     2  Kendel Jones, 12          8:10.5   16:17.8    5:15  Elk Lake

KarmaRush Example:
1	Travis Furmanski
Cedar Crest [12] - 4570
14:53.8

RunSignup Example:
1    1    
A
Ariana
Akey
12    251    Mountain Vista High School    20:00.8    6:27/M"></textarea>
                <div id="inputError" class="error-message"></div>
            </div>
            
            <div class="button-row">
                <button class="btn btn-primary" onclick="extractResults()">
                    Extract Results
                </button>
                <button class="btn btn-secondary" onclick="loadSample()">
                    Load Sample
                </button>
                <button class="btn btn-warning" onclick="clearAll()">
                    Clear All
                </button>
                <button class="btn btn-success" onclick="copyAsSpreadsheet()">
                    Copy for Excel
                </button>
                
                <div class="format-selector">
                    <label for="delimiter">Export Format:</label>
                    <select id="delimiter">
                        <option value="tab">Tab (Excel/Sheets)</option>
                        <option value="csv">CSV</option>
                        <option value="pipe">Pipe (|)</option>
                    </select>
                </div>
            </div>
            
            <div class="stats-bar">
                <div class="stat">
                    <span class="stat-label">Total Results:</span>
                    <span id="rowCount" class="stat-value">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Platform:</span>
                    <span id="platform" class="stat-value">-</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Status:</span>
                    <span id="status" class="stat-value">Ready</span>
                </div>
            </div>
        </div>

        <div class="table-container">
            <div class="table-header">
                <div class="table-title">Extracted Results</div>
                <button class="btn btn-secondary" style="padding: 8px 16px;" onclick="copyTableData()">
                    Copy Table
                </button>
            </div>
            <div class="table-wrapper">
                <table class="results-table" id="resultsTable">
                    <thead>
                        <tr>
                            <th>Place</th>
                            <th>Bib</th>
                            <th>Name</th>
                            <th>Grade</th>
                            <th>Team</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <tr>
                            <td colspan="6" class="empty-state">
                                <div class="empty-state-icon">üìã</div>
                                <div>No results yet. Paste race data above and click "Extract Results"</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        let extractedResults = [];

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function showError(message) {
            const errorEl = document.getElementById('inputError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, 5000);
        }

        function extractResults() {
            const input = document.getElementById('input').value;
            
            if (!input.trim()) {
                showError('Please paste race results into the input area');
                return;
            }

            document.getElementById('status').textContent = 'Processing...';
            extractedResults = [];

            try {
                const lines = input.trim().split('\n').map(line => line.trim()).filter(line => line);
                
                // Skip header content - find where results actually start
                // First, look for "Individuals" section or the all-results header (RunHigh format)
                let individualsIndex = -1;
                let teamResultsEnd = -1;

                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].match(/^Individuals$/i) ||
                        lines[i].match(/ID#\s+POINTS/i) ||
                        lines[i].match(/ID#\s+PLACE\s+SCORE\s+FINISHER/i) ||
                        lines[i].match(/^Top$/i) ||
                        lines[i].match(/Place\s+Bib\s+Name/i) ||
                        lines[i].match(/Individual Results/i) ||
                        lines[i].match(/Place\s+Name\s+Grade\s+Team\s+Time/i)) {
                        individualsIndex = i;
                        break;
                    }

                    // RCC Timing: Skip "Team Overall Results" section
                    if (lines[i].match(/Team Overall Results|Team Results|Individual Overall Results/i)) {
                        // Find where team results end (look for first individual result line)
                        for (let j = i + 1; j < lines.length; j++) {
                            // Individual results have: Overall, Score, Bib, Name, Class, Time, Team
                            // Class can be SR/JR/SO/FR (high school) or 6th/7th/8th or 6/7/8 (middle school) or missing
                            if (lines[j].match(/^\d+\s+(\d+|\(?\d+\)?)\s+\d{2,5}\s+\w+.*\s+(SR|JR|SO|FR|[678]th?|1[0-2]th?)?\s+\d{2}:\d{2}:\d{2}\.\d/i)) {
                                teamResultsEnd = j;
                                individualsIndex = j;
                                break;
                            }
                        }
                        if (teamResultsEnd >= 0) break;
                    }
                }

                // Search for first data line (starting from Individuals section if found)
                const searchStart = individualsIndex >= 0 ? individualsIndex : 0;
                let startIndex = -1;

                for (let i = searchStart; i < lines.length; i++) {
                    const line = lines[i];
                    // Tiffin format: "1 Andrew Seiverth 12 Perrysburg 17:35.4 1"
                    if (line.match(/^1\s+\w+\s+\w+\s+(7|8|9|10|11|12)\s+[\w\s.'-]+\s+\d{1,2}:\d{2}\.\d(\s+\d+)?\s*$/)) {
                        startIndex = i;
                        break;
                    }
                    // RaceDay Scoring format: "1    211    Teagan Kennedy        Maumee    1    36    1    00:18:03.10    5:49"
                    if (line.match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d+\s+\d{1,2}:\d{2}\s*$/)) {
                        startIndex = i;
                        break;
                    }
                    // Webscorer format: "1    7072    Boyd Hamby"
                    if (i + 2 < lines.length) {
                        const line1Parts = line.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);
                        if (line1Parts.length >= 3 &&
                            line1Parts[0] === '1' &&
                            line1Parts[1].match(/^\d{3,5}$/) &&
                            lines[i + 1].match(/^[A-Za-z\s]+-\s*\d{1,2}\s*$/) &&
                            lines[i + 2].match(/\d{1,2}:\d{2}\.\d{2}/)) {
                            startIndex = i;
                            break;
                        }
                    }
                    // Oklahoma format: "1 99 Tatum Penland 10 Bixby High School 1 00:19:15 6:12"
                    if (line.match(/^1\s+\d{1,5}\s+\w+\s+\w+\s+(9|10|11|12)\s+\w+.*\s+\d+\s+\d{2}:\d{2}/i)) {
                        startIndex = i;
                        break;
                    }
                    // RCC Timing: "1 1 353 Noah Bontrager SR 00:15:21.54 Westview"
                    // Middle school: "1 1 4788 Emmett Glenn 8th 00:10:11.64 Bellmont"
                    if (line.match(/(SR|JR|SO|FR|[678]th?|1[0-2]th?)\s+\d{2}:\d{2}:\d{2}\.\d/i) && line.match(/^1\s+/)) {
                        startIndex = i;
                        break;
                    }
                    // Web Timer: "1    889    Name    00:12:45.9..."
                    if (line.match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d/i)) {
                        startIndex = i;
                        break;
                    }
                    // VFP: "1 (< 5) 594 Name..." or "1 1 35 Name..." - has pace at end
                    if (line.match(/^1\s+(\d+|\(.*\)).*\d{1,2}:\d{2}\/M\s*$/i)) {
                        startIndex = i;
                        break;
                    }
                    // Runnercard: "1.    58    River Shaw    Jr    1.    Grand County HS    16:52.9    1"
                    if (line.match(/^1\.\s+\d{1,3}\s+\w+\s+\w+\s+(Fr|So|Jr|Sr)\s+\d+\.\s+[\w\s]+\s+\d{1,2}:\d{2}\.\d/i)) {
                        startIndex = i;
                        break;
                    }
                    // Athlete Guild Format 1: "Name    Bib    Team    Rank    Time..."
                    // Athlete Guild Format 2: "Name    Bib    Place    Time    Pace    Team"
                    // Check for name pattern followed by bib number
                    if (line.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d{1,4}(\t|\s{2,})/i)) {
                        startIndex = i;
                        break;
                    }
                    // Endurance Splits: "1    1    1164    Name..."
                    if (line.match(/^1(\t|\s{2,})1(\t|\s{2,})\d{3,4}(\t|\s{2,})[A-Z]/i)) {
                        startIndex = i;
                        break;
                    }
                    // Space-delimited: "1 NAME (TEAM) ..." or multi-line with team on next line
                    if (line.match(/^1\s+[A-Z]+.*\([A-Z]{3,4}\)/i) ||
                        (line.match(/^1\s+[A-Z\s]+\s+[A-Z\s,]+\s+[MF]R?:/i) &&
                         i + 1 < lines.length &&
                         lines[i + 1].match(/^\([A-Z]{3,4}\)/i))) {
                        startIndex = i;
                        break;
                    }
                    // RunHigh: starts with whitespace and 3-4 digit number followed by more numbers
                    // Format: " 1668     1     1  Gabe Simkiss, 11..."
                    if (line.match(/^\s*\d{3,4}\s+\d+\s+\d+\s+\w/)) {
                        startIndex = i;
                        break;
                    }
                    // RCC Timing individual results: "1 1 353 Noah Bontrager SR 00:15:21.54 Westview"
                    if (line.match(/^1\s+\d+\s+\d{2,5}\s+\w+.*\s+(SR|JR|SO|FR)\s+\d{2}:\d{2}:\d{2}\.\d/i)) {
                        startIndex = i;
                        break;
                    }
                    // KarmaRush/other formats: line starting with place number
                    if (line.match(/^1(\t|$)/)) {
                        startIndex = i;
                        break;
                    }
                }

                if (startIndex === -1) {
                    showError('Could not find the start of race results. Make sure you copied the results table.');
                    document.getElementById('status').textContent = 'Error';
                    return;
                }
                
                const resultLines = lines.slice(startIndex);
                
                // Try to detect format
                let hasKarmaRushPattern = false;
                let hasRunSignupPattern = false;
                let hasMileSplitPattern = false;
                let hasRunHighPattern = false;
                
                let hasSpaceDelimitedPattern = false;
                let hasEnduranceSplitsPattern = false;
                let hasAthleteGuildPattern = false;
                let hasVFPPattern = false;
                let hasWyoPrepsPattern = false;
                let hasRunnercardPattern = false;
                let hasWebTimerPattern = false;
                let hasRCCPattern = false;
                let hasOklahomaPattern = false;
                let hasWebscorerPattern = false;
                let hasRaceDayPattern = false;
                let hasTiffinPattern = false;
                let hasMeetProPattern = false;

                for (let i = 0; i < Math.min(resultLines.length, 30); i++) {
                    // MeetPro format: "1    ESEVERRI, Diego    SR    568    Columbus    1    15:30.6    ---    4:59.2"
                    // Also: "1    SARCOS, Valentina        1939    Miami Vice Project    --    11:34.6    ---    6:13.4" (no grade)
                    // Pattern: Place, Name (LAST, First), Year (optional), Bib, Team, Score, Time, Gap, Avg. Mile
                    // Key: Last name first with comma, has gap column (--- or time), tab or multi-space separated
                    if (resultLines[i].match(/^1\s+[A-Z]+,\s+\w+(\s+(FR|SO|JR|SR|[6-8]))?\s+\d{1,5}\s+[\w\s.'-]+\s+(--|\d+)\s+\d{1,2}:\d{2}\.\d+\s+(---|(\d{1,2}:\d{2}\.\d+|\d+\.\d+))\s+\d{1,2}:\d{2}\.\d/i)) {
                        hasMeetProPattern = true;
                        break;
                    }
                    // Tiffin format: "1 Andrew Seiverth 12 Perrysburg 17:35.4 1"
                    // Pattern: Place, Name, Grade (7-12), Team, Time (MM:SS.S), Points (optional)
                    // Key: Single-space separated with MM:SS.S time format (1 decimal)
                    if (resultLines[i].match(/^1\s+\w+\s+\w+\s+(7|8|9|10|11|12)\s+[\w\s.'-]+\s+\d{1,2}:\d{2}\.\d(\s+\d+)?\s*$/)) {
                        hasTiffinPattern = true;
                        break;
                    }
                    // RaceDay Scoring format: "1    211    Teagan Kennedy        Maumee    1    36    1    00:18:03.10    5:49"
                    // Pattern: Place, Bib, Name, Year, Team, Score, TeamScore, TeamPlace, Time (HH:MM:SS.XX), Pace
                    // Key identifier: Has pace at end (M:SS format) AND time with HH:MM:SS format
                    if (resultLines[i].match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d+\s+\d{1,2}:\d{2}\s*$/)) {
                        hasRaceDayPattern = true;
                        break;
                    }
                    // Webscorer format: 3 lines per runner
                    // Line 1: "1    7072    Boyd Hamby"
                    // Line 2: "Mcloud - 12"
                    // Line 3: "High School Boys    M    16:49.62    -"
                    if (i + 2 < resultLines.length) {
                        const line1Parts = resultLines[i].split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);
                        if (line1Parts.length >= 3 &&
                            line1Parts[0] === '1' &&
                            line1Parts[1].match(/^\d{3,5}$/) &&
                            resultLines[i + 1].match(/^[A-Za-z\s]+-\s*\d{1,2}\s*$/) &&
                            resultLines[i + 2].match(/\d{1,2}:\d{2}\.\d{2}/)) {
                            hasWebscorerPattern = true;
                            break;
                        }
                    }
                    // Oklahoma format: "1 99 Tatum Penland 10 Bixby High School 1 00:19:15 6:12"
                    // Pattern: Place, Bib, Name, Grade (9-12), Team, Score, Time, Pace
                    if (resultLines[i].match(/^1\s+\d{1,5}\s+\w+\s+\w+\s+(9|10|11|12)\s+\w+.*\s+\d+\s+\d{2}:\d{2}:\d{2}?\s+\d{1,2}:\d{2}/i)) {
                        hasOklahomaPattern = true;
                        break;
                    }
                    // RCC Timing format: "1 1 353 Noah Bontrager SR 00:15:21.54 Westview"
                    // Middle school: "1 1 4788 Emmett Glenn 8th 00:10:11.64 Bellmont"
                    // Pattern: Overall, Score, Bib, Name, Class (SR/JR/SO/FR or 6th/7th/8th or 6/7/8 or missing), Time, Team
                    // Look for Class marker and time format (with optional 00: prefix)
                    if (resultLines[i].match(/(SR|JR|SO|FR|[678]th?|1[0-2]th?)\s+\d{2}:\d{2}:\d{2}\.\d/i)) {
                        hasRCCPattern = true;
                        break;
                    }
                    // Web Timer format: "1    889    Name    00:12:45.9    All Ages    1    Female..."
                    // Pattern: Place, Bib, Name, Time (00:HH:MM.S format)
                    if (resultLines[i].match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d/i)) {
                        hasWebTimerPattern = true;
                        break;
                    }
                    // VFP format: "Place Score Bib No Name Team Grade Time Pace"
                    // Pattern: starts with "1" followed by number/score, has pace at end like "6:04/M"
                    // Examples: "1 (< 5) 594 Name Team 9 12:08.84 6:04/M"
                    //           "1 1 35 Lionel Vargas MARTIN 10 16:55.0 5:27/M"
                    if (resultLines[i].match(/^1\s+(\d+|\(.*\)).*\d{1,2}:\d{2}\/M\s*$/i)) {
                        hasVFPPattern = true;
                        break;
                    }
                    // WyoPreps format: "Place    Bib    Name    Year    Team Name    Score    Team Score    Team Place    Clock Time    Pace"
                    // Pattern: 4-digit bib, grade (9-12), time (MM:SS.S), pace without /M (M:SS)
                    // Example: "1    3677    Raina Wachob    10    Cody High School    1    19    1    20:59.7    6:46"
                    // Key: Has pace at end (M:SS) without /M suffix, time is MM:SS.S, score can be "(7)" or "> 7"
                    if (resultLines[i].match(/^1\s+\d{4}\s+\w+\s+\w+\s+(9|10|11|12)\s+.*\s+\d{1,2}:\d{2}\.\d\s+\d{1,2}:\d{2}\s*$/)) {
                        hasWyoPrepsPattern = true;
                        break;
                    }
                    // Runnercard format: "Place.    Bib    Name    Year    Team    Time    Score"
                    // Pattern: Place with period, bib (1-3 digits), name, year (Fr/So/Jr/Sr), team (starts with team place), time (MM:SS.S)
                    // Example: "1.    58    River Shaw    Jr    1.    Grand County HS    16:52.9    1"
                    // Key: Place ends with period, team field starts with number followed by period
                    if (resultLines[i].match(/^1\.\s+\d{1,3}\s+\w+\s+\w+\s+(Fr|So|Jr|Sr)\s+\d+\.\s+[\w\s]+\s+\d{1,2}:\d{2}\.\d/i)) {
                        hasRunnercardPattern = true;
                        break;
                    }
                    // Athlete Guild format: "Name    Bib    Team    Rank    Chip Time    Pace"
                    // Or: "Name    Bib    Place    Time    Pace    Team"
                    // Pattern: Name (two words), Bib (1-4 digits), then either team name or place number
                    if (resultLines[i].match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d{1,4}(\t|\s{2,})/i)) {
                        hasAthleteGuildPattern = true;
                        break;
                    }
                    // Endurance Splits format: "1    1    1164    Sofia Lauren Garza    Mission Sharyland    18:18.8    5:54/M"
                    if (resultLines[i].match(/^\d+(\t|\s{2,})\d+(\t|\s{2,})\d{3,4}(\t|\s{2,})[A-Z]/i)) {
                        hasEnduranceSplitsPattern = true;
                        break;
                    }
                    // Space-delimited format: "1 EMILY GROSS (DUMA) DUMAS, TX F: 1 SO 1596 00:11:27.55..."
                    if (resultLines[i].match(/^\d+\s+[A-Z]+.*\([A-Z]{3,4}\).*[MF]R?:\s*\d+\s+(FR|SO|JR|SR|8th)/i)) {
                        hasSpaceDelimitedPattern = true;
                        break;
                    }
                    // Multi-line space-delimited: team on next line
                    if (resultLines[i].match(/^\d+\s+[A-Z\s]+\s+[A-Z\s,]+\s+[MF]R?:\s*\d+\s+(FR|SO|JR|SR|8th)/i) &&
                        i + 1 < resultLines.length &&
                        resultLines[i + 1].match(/^\([A-Z]{3,4}\)/i)) {
                        hasSpaceDelimitedPattern = true;
                        break;
                    }
                    // RunHigh: Look for pattern with ID# at start followed by place/score and name
                    // Format: " 1668     1     1  Gabe Simkiss, 11          8:11.2   16:13.7..."
                    if (resultLines[i].match(/^\d{3,4}\s+\d+\s+\d+\s+[A-Z]/i)) {
                        hasRunHighPattern = true;
                        break;
                    }
                    // KarmaRush
                    if (resultLines[i].match(/\[(\d{1,2}|fr|so|jr|sr)\]\s*-\s*\d+/i)) {
                        hasKarmaRushPattern = true;
                        break;
                    }
                    // MileSplit
                    if (resultLines[i].match(/Logo/i) || resultLines[i].match(/#\d+/)) {
                        hasMileSplitPattern = true;
                        break;
                    }
                    // RunSignup
                    if (resultLines[i].match(/^[A-Z]$/) && i + 2 < resultLines.length &&
                        resultLines[i+1].match(/^[A-Z][a-z]+$/) &&
                        resultLines[i+2].match(/^[A-Z][a-z]+$/)) {
                        hasRunSignupPattern = true;
                        break;
                    }
                }

                if (hasMeetProPattern) {
                    // Process MeetPro format
                    let lastHeaderCandidate = null;
                    let justSawRaceNumber = false;

                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check if this is a "Race #X" line
                        if (line.match(/^Race\s+#\d+/i)) {
                            justSawRaceNumber = true;
                            continue; // Skip this line, but remember we saw it
                        }

                        // Check for race headers (e.g., "1A 2A JV Boys", "MS Boys 3000")
                        // Pattern: contains "boys" or "girls" or "varsity" or "jv" and is a short line without data structure
                        // Also skip table header lines like "Individual Results", "Athlete", etc.
                        if (line &&
                            line.match(/(?:boys|girls|men|women|varsity|jv)/i) &&
                            !line.includes('\t') &&
                            !line.match(/^\d+\s{2,}/) &&
                            !line.match(/^(Place|Athlete|Individual|Team|Final|Yr\.|#|Score|Time|Gap|Avg)/i) &&
                            line.length < 50) {
                            // If we just saw "Race #X", this is definitely a header
                            if (justSawRaceNumber) {
                                lastHeaderCandidate = line.toUpperCase();
                                justSawRaceNumber = false;
                            } else {
                                // Store as candidate, don't add yet
                                lastHeaderCandidate = line.toUpperCase();
                            }
                        }
                        // Check if we're at "Individual Results" - this means the last header candidate is the real header
                        else if (line.match(/^Individual\s+Results/i) && lastHeaderCandidate) {
                            // Add the header now that we know it's real
                            extractedResults.push({
                                isHeader: true,
                                headerText: lastHeaderCandidate,
                                place: '',
                                bib: '',
                                name: '',
                                team: '',
                                time: '',
                                grade: '',
                                points: '',
                                pace: ''
                            });
                            lastHeaderCandidate = null; // Clear it so we don't add it again
                        } else {
                            justSawRaceNumber = false; // Reset if we see any other line

                            let result = parseMeetProFormat(line);
                            if (result) {
                                // If we have a header candidate and we're parsing actual results, add the header first
                                if (lastHeaderCandidate) {
                                    extractedResults.push({
                                        isHeader: true,
                                        headerText: lastHeaderCandidate,
                                        place: '',
                                        bib: '',
                                        name: '',
                                        team: '',
                                        time: '',
                                        grade: '',
                                        points: '',
                                        pace: ''
                                    });
                                    lastHeaderCandidate = null;
                                }
                                extractedResults.push(result);
                            }
                        }
                    }
                } else if (hasTiffinPattern) {
                    // Process Tiffin format
                    // Handle multi-line names by merging continuation lines
                    for (let i = 0; i < resultLines.length; i++) {
                        let line = resultLines[i];

                        // Check if next line is a continuation (doesn't start with a number)
                        // and current line starts with a number
                        if (line.match(/^\d+\s/) && i + 1 < resultLines.length &&
                            !resultLines[i + 1].match(/^\d+/) &&
                            resultLines[i + 1].trim().length > 0 &&
                            !resultLines[i + 1].match(/^Page\s|^Race\s|^Place\s/i)) {
                            // Merge the continuation line
                            line = line + ' ' + resultLines[i + 1];
                            i++; // Skip the next line since we merged it
                        }

                        let result = parseTiffinFormat(line);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasRaceDayPattern) {
                    // Process RaceDay Scoring format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRaceDayFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasWebscorerPattern) {
                    // Process Webscorer format (3 lines per runner)
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseWebscorerFormat(resultLines, i);
                        if (result) {
                            extractedResults.push(result);
                            i += (result.linesConsumed - 1); // Skip the lines we just processed
                        }
                    }
                } else if (hasOklahomaPattern) {
                    // Process Oklahoma format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseOklahomaFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasRCCPattern) {
                    // Process RCC Timing format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRCCFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasWebTimerPattern) {
                    // Process Web Timer format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseWebTimerFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasVFPPattern) {
                    // Process VFP format
                    // First, identify team names from the data
                    const knownTeams = identifyVFPTeams(resultLines);

                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseVFPFormat(resultLines[i], knownTeams);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasWyoPrepsPattern) {
                    // Process WyoPreps format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseWyoPrepsFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasRunnercardPattern) {
                    // Process Runnercard format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRunnercardFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasAthleteGuildPattern) {
                    // Process Athlete Guild format
                    // Look for race headers like "Varsity Girls - Overall", "JV Boys - Overall"
                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check for race header pattern
                        // Pattern: "Varsity Girls - Overall", "JV Boys - Overall", "7th Grade Girls - Overall"
                        if (line.match(/^(Varsity|JV|7th Grade|8th Grade)\s+(Boys?|Girls?)\s+-\s+Overall$/i)) {
                            extractedResults.push({
                                isHeader: true,
                                headerText: line.toUpperCase(),
                                place: '',
                                bib: '',
                                name: '',
                                team: '',
                                time: '',
                                grade: '',
                                points: '',
                                pace: ''
                            });
                            continue;
                        }

                        let result = parseAthleteGuildFormat(line);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasEnduranceSplitsPattern) {
                    // Process Endurance Splits format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseEnduranceSplitsFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasSpaceDelimitedPattern) {
                    // Process space-delimited format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseSpaceDelimitedFormat(resultLines[i], i + 1 < resultLines.length ? resultLines[i + 1] : '');
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasRunHighPattern) {
                    // Process RunHigh format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRunHighFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasKarmaRushPattern) {
                    // Process KarmaRush format
                    let i = 0;
                    while (i < resultLines.length) {
                        if (resultLines[i].match(/^\d+\t/)) {
                            let result = parseKarmaRushTabFormat(resultLines, i);
                            if (result) {
                                extractedResults.push(result);
                                i = result.nextIndex;
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                } else if (hasMileSplitPattern) {
                    // Process MileSplit format
                    let i = 0;
                    while (i < resultLines.length) {
                        if (resultLines[i].match(/^(\d+|--)$/)) {
                            let result = parseMileSplitFormat(resultLines, i);
                            if (result) {
                                extractedResults.push(result);
                                i = result.nextIndex;
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                } else if (hasRunSignupPattern) {
                    // Process RunSignup format
                    let i = 0;
                    while (i < resultLines.length) {
                        if (resultLines[i].match(/^\d+(\t|$)/)) {
                            let result = parseRunSignupFormat(resultLines, i);
                            if (result) {
                                extractedResults.push(result);
                                i = result.nextIndex;
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                } else {
                    showError('Could not detect data format. Please ensure you copied the entire results table.');
                    document.getElementById('status').textContent = 'Error';
                    return;
                }

                if (extractedResults.length === 0) {
                    showError('Could not extract any valid results. Please check the format.');
                    document.getElementById('status').textContent = 'Error';
                    return;
                }

                displayResults();
                
                document.getElementById('rowCount').textContent = extractedResults.length;
                document.getElementById('platform').textContent = detectPlatform(input);
                document.getElementById('status').textContent = 'Complete';
                
                showToast(`Extracted ${extractedResults.length} results!`);
                
            } catch (error) {
                console.error('Extraction error:', error);
                showError('Error processing input. Please try again.');
                document.getElementById('status').textContent = 'Error';
            }
        }
        
        function parseEnduranceSplitsFormat(line) {
            // Format: "1    1    1164    Sofia Lauren Garza    Mission Sharyland    18:18.8    5:54/M"
            // Columns: O'All Place, Score, Bib No, Name, Team, Time, Pace
            // Skip lines with (< 5) or similar in score column

            // Split by tabs first, then by multiple spaces if no tabs
            let parts;
            if (line.includes('\t')) {
                parts = line.trim().split('\t').map(p => p.trim()).filter(p => p);
            } else {
                // For space-delimited, use a more careful split
                // Match content in parentheses OR sequences of non-space chars
                parts = line.trim().match(/\([^)]*\)|\S+/g);
                if (!parts) return null;
            }

            if (parts.length < 6) return null;

            // First part should be a number (O'All Place)
            if (!parts[0].match(/^\d+$/)) return null;

            let partIndex = 0;

            // O'All Place - use this as the place
            const place = parts[partIndex];
            if (!place.match(/^\d+$/)) return null;
            partIndex++;

            // Score - skip this column entirely
            partIndex++;

            // Bib number
            const bib = parts[partIndex];
            if (!bib.match(/^\d{3,4}$/)) return null;
            partIndex++;

            // Name
            const name = parts[partIndex];
            if (!name || name.length === 0) return null;
            partIndex++;

            // Team
            const team = parts[partIndex];
            if (!team || team.length === 0) return null;
            partIndex++;

            // Time
            const time = parts[partIndex];
            if (!time || !time.match(/\d+:\d+/)) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: '',
                points: '',
                pace: ''
            };
        }

        function identifyVFPTeams(lines) {
            // First pass: identify team names by finding repeated patterns at the end of lines
            const potentialTeams = {};

            for (const line of lines) {
                const trimmed = line.trim();
                const paceMatch = trimmed.match(/\s+(\d{1,2}:\d{2}\/M)\s*$/);
                if (!paceMatch) continue;

                let remaining = trimmed.substring(0, trimmed.length - paceMatch[0].length);
                const timeMatch = remaining.match(/\s+(\d{1,2}:\d{2}\.\d{1,2})\s*$/);
                if (!timeMatch) continue;

                remaining = remaining.substring(0, remaining.length - timeMatch[0].length);
                const gradeMatch = remaining.match(/\s+(\d{1,2}T?)\s*$/);
                if (!gradeMatch) continue;

                remaining = remaining.substring(0, remaining.length - gradeMatch[0].length);

                // Extract everything after the bib number
                const parts = remaining.trim().split(/\s+/);
                if (parts.length < 5) continue; // Need Place Score Bib Name Team

                // Find bib (2-4 digit number after score)
                let bibIndex = -1;
                for (let i = 2; i < Math.min(parts.length, 5); i++) {
                    if (parts[i].match(/^\d{2,4}$/)) {
                        bibIndex = i;
                        break;
                    }
                }
                if (bibIndex === -1) continue;

                const afterBib = parts.slice(bibIndex + 1);
                if (afterBib.length < 3) continue;

                // Try different team name lengths (1-4 words from the end)
                for (let teamLen = 1; teamLen <= Math.min(4, afterBib.length - 2); teamLen++) {
                    const teamName = afterBib.slice(-teamLen).join(' ');
                    potentialTeams[teamName] = (potentialTeams[teamName] || 0) + 1;
                }
            }

            // Return teams that appear 2+ times
            const confirmedTeams = Object.keys(potentialTeams)
                .filter(team => potentialTeams[team] >= 2)
                .sort((a, b) => b.split(' ').length - a.split(' ').length); // Longer names first

            return confirmedTeams;
        }

        function parseVFPFormat(line, knownTeams = []) {
            // Format: "Place    Score    Bib No    Name    Team    Grade    Time    Pace"
            // Example: "1    (< 5)    594    Jose Luis Flores    Laredo Harmony School    9    12:08.84    6:04/M"
            // When copied from PDF: "1 (< 5) 594 Jose Luis Flores Laredo Harmony School 9 12:08.84 6:04/M"

            const trimmed = line.trim();

            // Extract from right to left (more reliable):
            // Pace at end: "6:04/M" or "5:27/M"
            const paceMatch = trimmed.match(/\s+(\d{1,2}:\d{2}\/M)\s*$/);
            if (!paceMatch) return null;
            let remaining = trimmed.substring(0, trimmed.length - paceMatch[0].length);

            // Time before pace: "12:08.84" or "16:55.0" (1 or 2 decimal places)
            const timeMatch = remaining.match(/\s+(\d{1,2}:\d{2}\.\d{1,2})\s*$/);
            if (!timeMatch) return null;
            const time = timeMatch[1];
            remaining = remaining.substring(0, remaining.length - timeMatch[0].length);

            // Grade before time: "9", "10", "11", "12", or "9T" (with optional T)
            // Grade is optional - some entries may not have it
            const gradeMatch = remaining.match(/\s+(\d{1,2}T?)\s*$/);
            let grade = '';
            if (gradeMatch) {
                grade = gradeMatch[1].replace(/T$/i, ''); // Remove trailing T
                remaining = remaining.substring(0, remaining.length - gradeMatch[0].length);
            }

            // Now from left: Place, Score, Bib, Name, Team
            // Could be: "1 1 35 Lionel Vargas MARTIN" or "1 (< 5) 594 Jose Luis Flores Laredo"
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 4) return null;

            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Find the bib number - it's a 2-4 digit number that comes after score
            // Score could be a number or (< 5) or (> 7) or (<, 5) or (>, 7)
            let bibIndex = -1;

            if (parts[1].match(/^\(/) || parts[1] === '(<' || parts[1] === '(>') {
                // Score is "(< 5)" or "(> 7)" which might be split as "(<", "5)" or "(>", "7)" or as single token
                if (parts[1] === '(<' || parts[1] === '(>') {
                    // Split as "(<" "5)" or "(>" "7)" - bib is at index 3
                    bibIndex = 3;
                } else {
                    // "(< 5)" or "(> 7)" as single token - bib is at index 2
                    bibIndex = 2;
                }
            } else if (parts[1].match(/^\d+$/)) {
                // Score is a number - bib is at index 2
                bibIndex = 2;
            } else {
                return null; // Invalid score format
            }

            if (bibIndex >= parts.length) return null;
            const bib = parts[bibIndex];
            // Bib can be 1-4 digits (1, 35, 594, etc.)
            if (!bib.match(/^\d{1,4}$/)) return null;

            // Everything between bib and grade is Name + Team
            const nameTeamParts = parts.slice(bibIndex + 1);
            if (nameTeamParts.length < 3) return null; // Need at least First Last Team

            let name, team;

            // If we have known teams, try to match from the end
            if (knownTeams && knownTeams.length > 0) {
                const nameTeamStr = nameTeamParts.join(' ');
                let matched = false;

                // Try to match known teams (longest first)
                for (const knownTeam of knownTeams) {
                    if (nameTeamStr.endsWith(knownTeam)) {
                        team = knownTeam;
                        name = nameTeamStr.substring(0, nameTeamStr.length - knownTeam.length).trim();
                        matched = true;
                        break;
                    }
                }

                if (!matched) {
                    // Fallback to 2-word name
                    name = nameTeamParts.slice(0, 2).join(' ');
                    team = nameTeamParts.slice(2).join(' ');
                }
            } else {
                // No known teams, use simple heuristic: First 2 words are name
                name = nameTeamParts.slice(0, 2).join(' ');
                team = nameTeamParts.slice(2).join(' ');
            }

            if (!team || team.length === 0 || !name || name.length === 0) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: ''
            };
        }

        function parseWyoPrepsFormat(line) {
            // Format: "Place    Bib    Name    Year    Team Name    Score    Team Score    Team Place    Clock Time    Pace"
            // Example: "1    3677    Raina Wachob    10    Cody High School    1    19    1    20:59.7    6:46"
            // Example: "7    3670    Danielle Foote    10    Cody High School    (7)    19    1    22:32.0    7:16"
            // Example: "13    3675    Sunday Schuh    12    Cody High School    > 7    19    1    22:58.6    7:25"
            // Pattern: Tab or multi-space separated
            // Score can be: number, (number), or "> 7"

            const trimmed = line.trim();

            // Parse from right to left (more reliable)
            // Pace at end: "6:46" (M:SS format without /M)
            const paceMatch = trimmed.match(/\s+(\d{1,2}:\d{2})\s*$/);
            if (!paceMatch) return null;
            const pace = paceMatch[1];
            let remaining = trimmed.substring(0, trimmed.length - paceMatch[0].length);

            // Clock Time before pace: "20:59.7" (MM:SS.S format)
            const timeMatch = remaining.match(/\s+(\d{1,2}:\d{2}\.\d)\s*$/);
            if (!timeMatch) return null;
            const time = timeMatch[1];
            remaining = remaining.substring(0, remaining.length - timeMatch[0].length);

            // Team Place before time: "1" (1 or 2 digits)
            const teamPlaceMatch = remaining.match(/\s+(\d{1,2})\s*$/);
            if (!teamPlaceMatch) return null;
            remaining = remaining.substring(0, remaining.length - teamPlaceMatch[0].length);

            // Team Score before Team Place: "19" (1-3 digits) or "Incomplete"
            const teamScoreMatch = remaining.match(/\s+(Incomplete|\d{1,3})\s*$/);
            if (!teamScoreMatch) return null;
            remaining = remaining.substring(0, remaining.length - teamScoreMatch[0].length);

            // Score before Team Score: can be number, (number), "> 7", "< 5", or "< 5" (with space)
            // Match any of these patterns
            const scoreMatch = remaining.match(/\s+(<|>)\s*(\d+|\(\d+\))\s*$/) || remaining.match(/\s+(\d+|\(\d+\))\s*$/);
            if (!scoreMatch) return null;
            remaining = remaining.substring(0, remaining.length - scoreMatch[0].length);

            // Now from left: Place, Bib, Name (2 words), Year, Team (multi-word)
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 6) return null; // Need Place, Bib, FirstName, LastName, Year, Team (at least 1 word)

            // Place
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Bib (4 digits, but could be 3 in some cases)
            const bib = parts[1];
            if (!bib.match(/^\d{3,5}$/)) return null;

            // Name (2 words: First Last)
            const firstName = parts[2];
            const lastName = parts[3];
            const name = `${firstName} ${lastName}`;

            // Year/Grade
            const year = parts[4];
            if (!year.match(/^(7|8|9|10|11|12)$/)) return null;

            // Team (everything remaining - could be multi-word)
            const team = parts.slice(5).join(' ');
            if (!team || team.length === 0) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: year,
                points: '',
                pace: pace
            };
        }

        function parseRunnercardFormat(line) {
            // Format: "Place.    Bib    Name    Year    Team    Time    Score"
            // Example: "1.    58    River Shaw    Jr    1.    Grand County HS    16:52.9    1"
            // Example: "27.    93    Noah Begay    Sr    8.    San Juan HS    18:58.8        " (no score - non-scoring)
            // Pattern: Tab or multi-space separated
            // Place ends with period, Team starts with team place number followed by period

            const trimmed = line.trim();

            // Parse from right to left for reliability
            // Score at end (optional - may be blank for non-scoring runners)
            let score = '';
            let remaining = trimmed;

            // Check if line ends with a score (1-2 digit number or blank spaces)
            const scoreMatch = trimmed.match(/\s+(\d{1,2})\s*$/);
            if (scoreMatch) {
                score = scoreMatch[1];
                remaining = trimmed.substring(0, trimmed.length - scoreMatch[0].length);
            }

            // Time before score: "16:52.9" (MM:SS.S format)
            const timeMatch = remaining.match(/\s+(\d{1,2}:\d{2}\.\d)\s*$/);
            if (!timeMatch) return null;
            const time = timeMatch[1];
            remaining = remaining.substring(0, remaining.length - timeMatch[0].length);

            // Team before time: starts with team place number and period "1.    Grand County HS"
            // Match: number, period, then team name (multi-word)
            const teamMatch = remaining.match(/\s+(\d+)\.\s+([\w\s]+?)\s*$/);
            if (!teamMatch) return null;
            const team = teamMatch[2].trim();
            remaining = remaining.substring(0, remaining.length - teamMatch[0].length);

            // Year/Grade before team: "Fr", "So", "Jr", "Sr"
            const yearMatch = remaining.match(/\s+(Fr|So|Jr|Sr)\s*$/i);
            if (!yearMatch) return null;
            const year = yearMatch[1];
            remaining = remaining.substring(0, remaining.length - yearMatch[0].length);

            // Now from left: Place (with period), Bib, Name (2 words)
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 4) return null; // Need Place., Bib, FirstName, LastName

            // Place (ends with period)
            const placeStr = parts[0];
            if (!placeStr.match(/^\d+\.$/)) return null;
            const place = placeStr.replace('.', '');

            // Bib (1-3 digits)
            const bib = parts[1];
            if (!bib.match(/^\d{1,3}$/)) return null;

            // Name (remaining words before year)
            const name = parts.slice(2).join(' ');
            if (!name || name.length === 0) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: year,
                points: score,
                pace: ''
            };
        }

        function parseRCCFormat(line) {
            // Format: "Overall Score Bib# Name Class Chip Time Team"
            // Example: "1 1 353 Noah Bontrager SR 00:15:21.54 Westview"
            // Example: "21 21 365 Nathan Troxel Gonzalez JR 00:18:08.34 West Noble"
            // Middle School: "1 1 4788 Emmett Glenn 8th 00:10:11.64 Bellmont"
            // Middle School (no class): "21 20 2519 Jacob Chacon 00:11:34.55 New Haven"
            // Score can be: number, 0, or (number) for non-scoring

            const trimmed = line.trim();

            // Work from right to left
            // First find Class and Time pattern
            // Class can be: SR, JR, SO, FR (high school) or 6th/7th/8th or 6/7/8 (middle school) or missing
            let classTimeMatch = trimmed.match(/\s+(SR|JR|SO|FR|[678]th?|1[0-2]th?)\s+(\d{2}:\d{2}:\d{2}\.\d+)\s+(.+?)\s*$/i);

            let classField = '';
            let time = '';
            let team = '';
            let remaining = '';

            if (classTimeMatch) {
                // Has class field
                classField = classTimeMatch[1];
                time = classTimeMatch[2];
                team = classTimeMatch[3];
                remaining = trimmed.substring(0, trimmed.length - classTimeMatch[0].length);
            } else {
                // No class field - try just time and team
                const timeTeamMatch = trimmed.match(/\s+(\d{2}:\d{2}:\d{2}\.\d+)\s+(.+?)\s*$/);
                if (!timeTeamMatch) return null;

                time = timeTeamMatch[1];
                team = timeTeamMatch[2];
                remaining = trimmed.substring(0, trimmed.length - timeTeamMatch[0].length);
            }

            // Remove leading "00:" from time
            if (time.startsWith('00:')) {
                time = time.substring(3);
            }

            // Now parse from left: Overall, Score, Bib#, Name
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 3) return null;

            // Overall
            const overall = parts[0];
            if (!overall.match(/^\d+$/)) return null;

            // Score (skip it - can be number, 0, or (number))
            let partIndex = 1;
            if (parts[1].match(/^\(?\d+\)?$/)) {
                partIndex = 2; // Skip score
            }

            // Bib#
            const bib = parts[partIndex];
            if (!bib.match(/^\d{2,5}$/)) return null;
            partIndex++;

            // Name (everything remaining)
            const name = parts.slice(partIndex).join(' ');
            if (!name || name.length === 0) return null;

            // Remove "th" suffix from grade (8th -> 8, 7th -> 7, etc.)
            let grade = classField;
            if (grade && grade.match(/^\d+th$/i)) {
                grade = grade.replace(/th$/i, '');
            }

            return {
                place: overall,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: ''
            };
        }

        function parseOklahomaFormat(line) {
            // Format: Place, Bib, Name, Grade, Team, Score, Time, Pace
            // Example: "1 99 Tatum Penland 10 Bixby High School 1 00:19:15 6:12"
            // Example: "21 119 Maggie Kershen 10 Norman High School (21) 00:21:37 6:58"
            // Score can be: number or (number) for non-scoring

            const trimmed = line.trim();

            // Parse from right to left
            // Pace at end: "6:12" or "5:27"
            const paceMatch = trimmed.match(/\s+(\d{1,2}:\d{2})\s*$/);
            if (!paceMatch) return null;
            const pace = paceMatch[1];
            let remaining = trimmed.substring(0, trimmed.length - paceMatch[0].length);

            // Time before pace: "00:19:15" or "19:15"
            const timeMatch = remaining.match(/\s+(\d{2}:\d{2}:?\d{0,2})\s*$/);
            if (!timeMatch) return null;
            let time = timeMatch[1];
            remaining = remaining.substring(0, remaining.length - timeMatch[0].length);

            // Remove leading "00:" from time
            if (time.startsWith('00:')) {
                time = time.substring(3);
            }

            // Score before time: number or (number)
            const scoreMatch = remaining.match(/\s+(\(?\d+\)?)\s*$/);
            if (!scoreMatch) return null;
            remaining = remaining.substring(0, remaining.length - scoreMatch[0].length);

            // Now parse from left: Place, Bib, Name (first last), Grade, Team
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 5) return null;

            // Place
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Bib
            const bib = parts[1];
            if (!bib.match(/^\d{1,5}$/)) return null;

            // Name (first last) - 2 words
            const name = parts[2] + ' ' + parts[3];

            // Grade (9, 10, 11, 12)
            const grade = parts[4];
            if (!grade.match(/^(9|10|11|12)$/)) return null;

            // Team (everything remaining)
            const team = parts.slice(5).join(' ');
            if (!team || team.length === 0) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: pace
            };
        }

        function parseWebscorerFormat(lines, index) {
            // Format: Place, Bib, Name on one line, Team-Grade on next line, Category, Gender, Time, Difference
            // Line 1: "1    7072    Boyd Hamby"
            // Line 2: "Mcloud - 12"
            // Line 3: "High School Boys    M    16:49.62    -"

            if (index + 2 >= lines.length) return null;

            const line1 = lines[index].trim();
            const line2 = lines[index + 1].trim();
            const line3 = lines[index + 2].trim();

            // Parse line 1: Place, Bib, Name (tab or multi-space separated)
            const parts1 = line1.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);
            if (parts1.length < 3) return null;

            const place = parts1[0];
            if (!place.match(/^\d+$/)) return null;

            const bib = parts1[1];
            if (!bib.match(/^\d{1,5}$/)) return null;

            const name = parts1[2];
            if (!name || name.length === 0) return null;

            // Parse line 2: Team - Grade
            // Example: "Mcloud - 12" or "Prague - 11"
            const teamGradeMatch = line2.match(/^(.+?)\s*-\s*(\d{1,2})\s*$/);
            if (!teamGradeMatch) return null;

            const team = teamGradeMatch[1].trim();
            const grade = teamGradeMatch[2];

            // Parse line 3: Category, Gender, Time, Difference
            const parts3 = line3.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);
            if (parts3.length < 2) return null;

            // Time format: MM:SS.XX
            let time = null;
            for (let i = 0; i < parts3.length; i++) {
                if (parts3[i].match(/^\d{1,2}:\d{2}\.\d{2}$/)) {
                    time = parts3[i];
                    break;
                }
            }
            if (!time) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: '',
                linesConsumed: 3 // This parser consumes 3 lines
            };
        }

        function parseRaceDayFormat(line) {
            // Format: Place, Bib, Name, Year, Team Name, Score, Team Score, Team Place, Clock Time, Pace
            // Example: "1    211    Teagan Kennedy        Maumee    1    36    1    00:18:03.10    5:49"
            // Score can be: number, (number), or "> 7"

            const trimmed = line.trim();

            // Split by tabs or multiple spaces
            const parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            if (parts.length < 8) return null;

            // Place - first column
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Bib - second column
            const bib = parts[1];
            if (!bib.match(/^\d{1,5}$/)) return null;

            // Name - third column
            const name = parts[2];
            if (!name || name.length === 0) return null;

            // Year - fourth column (often empty, skip it)
            let partIndex = 3;
            // If the next part looks like a year (9-12) or is empty, skip it
            if (parts[partIndex].match(/^(9|10|11|12)?$/)) {
                partIndex = 4;
            }

            // Team Name - should be at partIndex now
            const team = parts[partIndex];
            if (!team || team.length === 0) return null;
            partIndex++;

            // Score - can be number, (number), "> 7", or "Incomplete"
            // Skip this column
            partIndex++;

            // Team Score - skip
            partIndex++;

            // Team Place - skip
            partIndex++;

            // Clock Time
            let time = parts[partIndex];
            if (!time || !time.match(/\d{2}:\d{2}:\d{2}\.\d{2}/)) return null;

            // Remove leading "00:" from time
            if (time.startsWith('00:')) {
                time = time.substring(3);
            }

            // Pace (optional)
            const pace = parts.length > partIndex + 1 ? parts[partIndex + 1] : '';

            // Extract grade from Year column if it was there
            const grade = parts[3].match(/^(9|10|11|12)$/) ? parts[3] : '';

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: pace
            };
        }

        function parseMeetProFormat(line) {
            // Format: Place, Name (LAST, First), Yr., #, Team, Score, Time, Gap, Avg. Mile
            // Example: "1    ESEVERRI, Diego    SR    568    Columbus    1    15:30.6    ---    4:59.2"
            // Example: "2    GARGANO, Massimo    SR    567    Columbus    2    15:46.1    15.5    5:04.2"
            // Example: "1    MYERS, Colton    8    3006    Trinity    1    11:35.5    ---    5:47/M"
            // Example with no grade: "2    LEFKO, Noah        3275    WIND Runners    1    10:15.7    16.7    5:31.0"

            const trimmed = line.trim();

            // Skip non-data lines
            if (!trimmed || trimmed.match(/^(Place|Athlete|Individual|Team|---+|\d+\)|Yr\.|#|Score|Time|Gap|Avg)/i)) {
                return null;
            }

            // Split by tabs or multiple spaces
            let parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            // Need at least: Place, Name, Bib, Team, Score, Time (6 fields minimum if no grade)
            if (parts.length < 6) return null;

            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Name is in format "LAST, First" or "LAST, First Middle"
            const name = parts[1];
            if (!name || !name.includes(',')) return null;

            // Check if parts[2] is a grade (FR, SO, JR, SR, or 6-8) or a bib number
            let grade = '';
            let bibIndex = 2;

            if (parts[2] && parts[2].match(/^(FR|SO|JR|SR|[6-8])$/i)) {
                // Grade is present
                grade = parts[2].toUpperCase();
                bibIndex = 3;
            }
            // else: No grade, bibIndex stays at 2

            // Bib number
            const bib = parts[bibIndex];
            if (!bib || !bib.match(/^\d+$/)) return null;

            // Team name
            const team = parts[bibIndex + 1];
            if (!team || team.length === 0) return null;

            // Score (can be a number or "--" or other markers)
            const score = parts[bibIndex + 2];

            // Time (MM:SS.S format)
            const time = parts[bibIndex + 3];
            if (!time || !time.match(/^\d{1,2}:\d{2}\.\d/)) return null;

            // Gap is parts[bibIndex + 4] - we ignore it
            // Avg. Mile/Pace is parts[bibIndex + 5] - optional

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: score && score.match(/^\d+$/) ? score : '',
                pace: ''
            };
        }

        function parseTiffinFormat(line) {
            // Format: Place Name Grade Team Time Points
            // Example: "1 Andrew Seiverth 12 Perrysburg 17:35.4 1"
            // Example: "23 Christian Rodriguez 9 Perrysburg 18:44.5"
            // Note: Columns can be separated by single OR multiple spaces/tabs

            const trimmed = line.trim();

            // Try splitting by tabs or 2+ spaces first
            let parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            // If we got exactly 1 part, the line is likely space-separated
            // Parse from right-to-left since we know Time and Grade positions
            if (parts.length === 1 || parts.length < 5) {
                parts = trimmed.split(/\s+/);

                if (parts.length < 5) return null;

                // Parse from left and right
                const place = parts[0];
                if (!place.match(/^\d+$/)) return null;

                // Points (optional) - last column if it's a number AND there are enough parts
                let points = '';
                let endIndex = parts.length;

                // Check if last element is points (single/double digit number)
                if (parts.length >= 6 && parts[parts.length - 1].match(/^\d{1,2}$/)) {
                    // Make sure the second-to-last is the time
                    if (parts[parts.length - 2].match(/^\d{1,2}:\d{2}\.\d$/)) {
                        points = parts[parts.length - 1];
                        endIndex--;
                    }
                }

                // Time - before points (MM:SS.S format)
                const time = parts[endIndex - 1];
                if (!time || !time.match(/^\d{1,2}:\d{2}\.\d$/)) return null;
                endIndex--;

                // Find grade by scanning backwards from time
                // Grade is the first number (7-12) we find before the time
                let gradeIndex = -1;
                for (let i = endIndex - 1; i >= 1; i--) {
                    if (parts[i].match(/^(7|8|9|10|11|12)$/)) {
                        gradeIndex = i;
                        break;
                    }
                }
                if (gradeIndex === -1) return null;

                const grade = parts[gradeIndex];

                // Team - everything between grade and time
                const team = parts.slice(gradeIndex + 1, endIndex).join(' ');
                if (!team || team.length === 0) return null;

                // Name - everything between place and grade
                const name = parts.slice(1, gradeIndex).join(' ');
                if (!name || name.length === 0) return null;

                return {
                    place: place,
                    bib: '',
                    name: name,
                    team: team,
                    time: time,
                    grade: grade,
                    points: points,
                    pace: ''
                };
            }

            // Tab or multi-space separated
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            const name = parts[1];
            if (!name || name.length === 0) return null;

            const grade = parts[2];
            if (!grade.match(/^(7|8|9|10|11|12)$/)) return null;

            const team = parts[3];
            if (!team || team.length === 0) return null;

            const time = parts[4];
            if (!time || !time.match(/^\d{1,2}:\d{2}\.\d$/)) return null;

            const points = parts.length > 5 ? parts[5] : '';

            return {
                place: place,
                bib: '',
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: points,
                pace: ''
            };
        }

        function parseWebTimerFormat(line) {
            // Format from web timing systems with many columns
            // Example 1: "1    889    Hailyn Counts    00:12:45.9    All Ages    1    Female    1    Austin Brentwood Christian Acade    5    1..."
            // Columns: Pos, Race No, Name, Time, Division, Division Pos, Gender, Gen Pos, Team, Team Pos...
            // Example 2: "1    768    Marcus Benjamin    00:16:10.2    Varsity Boys    1    Male    Weyauwega-Fremont    1    5:12 min/m"
            // Columns: Pos, Race No, Name, Time, Age Group, Team Points, Gender, Team, Pos In Team, Pace

            // Split by tabs or multiple spaces
            const parts = line.trim().split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            if (parts.length < 8) return null;

            // Position (place) - first column
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Race No (bib) - second column
            const bib = parts[1];
            if (!bib.match(/^\d{1,5}$/)) return null;

            // Name - third column
            const name = parts[2];
            if (!name || name.length === 0) return null;

            // Time - fourth column (format: 00:12:45.9 or "Not started")
            let time = parts[3];
            if (!time || time === 'Not') return null; // Skip "Not started" entries
            if (!time.match(/\d{2}:\d{2}:\d{2}\.\d/)) return null;

            // Remove leading "00:" from time (convert 00:12:45.9 to 12:45.9)
            if (time.startsWith('00:')) {
                time = time.substring(3);
            }

            // Team - varies by format and whether Team Points is filled
            // Performance Timing with Team Points: Pos, Race No, Name, Time, Age Group, Team Points, Gender, Team, Pos In Team, Pace
            //   After split: [0-Pos, 1-RaceNo, 2-Name, 3-Time, 4-AgeGroup, 5-TeamPts, 6-Gender, 7-Team, 8-PosInTeam, 9-Pace]
            // Performance Timing without Team Points: Pos, Race No, Name, Time, Age Group, Gender, Team, Pos In Team, Pace
            //   After split: [0-Pos, 1-RaceNo, 2-Name, 3-Time, 4-AgeGroup, 5-Gender, 6-Team, 7-PosInTeam, 8-Pace]
            // Other Web Timer: Pos, Race No, Name, Time, Division, Division Pos, Gender, Gen Pos, Team, Team Pos
            //   After split: [0-Pos, 1-RaceNo, 2-Name, 3-Time, 4-Div, 5-DivPos, 6-Gender, 7-GenPos, 8-Team, 9-TeamPos]

            let team = null;

            // Find Gender column first
            let genderIndex = -1;
            for (let i = 5; i < Math.min(parts.length, 8); i++) {
                if (parts[i] === 'Male' || parts[i] === 'Female') {
                    genderIndex = i;
                    break;
                }
            }

            if (genderIndex === -1) return null;

            // Team is 1 or 2 positions after Gender
            if (genderIndex === 5) {
                // Performance Timing without Team Points: Gender at 5, Team at 6
                team = parts[6];
            } else if (genderIndex === 6) {
                // Performance Timing with Team Points: Gender at 6, Team at 7
                team = parts[7];
            } else if (genderIndex === 7) {
                // Other Web Timer: Gender at 7, skip Gen Pos, Team at 8
                team = parts.length > 8 ? parts[8] : null;
            }

            // Validate team is not a single/double digit number (which would be Pos In Team)
            if (!team || team.length === 0 || team.match(/^\d{1,2}$/)) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: '',
                points: '',
                pace: ''
            };
        }

        function parseAthleteGuildFormat(line) {
            // Format 1: "Name    Bib    Team    Rank    Chip Time    Pace"
            // Example: "Macee Rhodes    292    Utopia    1    14:24.429    11:35"
            // Format 2: "Name    Bib    Place    Time    Pace    Team"
            // Example: "Ella Morrison    114    1    12:42.950    6:21    Florence"

            // Split by tabs or multiple spaces (2+)
            const parts = line.trim().split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            if (parts.length < 5) return null;

            // First part should be a name (contains letters and possibly spaces)
            if (!parts[0].match(/^[A-Z][a-z]+(\s+[A-Z][a-z]+)+$/i)) return null;

            let partIndex = 0;

            // Name
            const name = parts[partIndex];
            partIndex++;

            // Bib number
            const bib = parts[partIndex];
            if (!bib.match(/^\d{1,4}$/)) return null;
            partIndex++;

            // Detect format by checking if next field is a number (place) or text (team)
            let place, team, time, pace;

            if (parts[partIndex].match(/^\d+$/)) {
                // Format 2: Name, Bib, Place, Time, Pace, Team
                place = parts[partIndex];
                partIndex++;

                // Time
                time = parts[partIndex];
                if (!time || !time.match(/\d+:\d+/)) return null;
                partIndex++;

                // Pace (optional)
                if (partIndex < parts.length && parts[partIndex].match(/^\d+:\d+$/)) {
                    pace = parts[partIndex];
                    partIndex++;
                }

                // Team (rest of the parts)
                team = parts.slice(partIndex).join(' ');
            } else {
                // Format 1: Name, Bib, Team, Rank, Time, Pace
                team = parts[partIndex];
                if (!team || team.length === 0) return null;
                partIndex++;

                // Rank (place)
                place = parts[partIndex];
                if (!place.match(/^\d+$/)) return null;
                partIndex++;

                // Chip Time
                time = parts[partIndex];
                if (!time || !time.match(/\d+:\d+/)) return null;
                partIndex++;

                // Pace (optional)
                if (partIndex < parts.length && parts[partIndex].match(/^\d+:\d+$/)) {
                    pace = parts[partIndex];
                }
            }

            // Round time to 2 decimal places if it has more
            const timeMatch = time.match(/^(\d+:\d+)\.(\d+)$/);
            if (timeMatch && timeMatch[2].length > 2) {
                const decimal = timeMatch[2].substring(0, 2);
                time = `${timeMatch[1]}.${decimal}`;
            }

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: '',
                points: '',
                pace: pace || ''
            };
        }

        function parseSpaceDelimitedFormat(line, nextLine) {
            // Format: "1 EMILY GROSS (DUMA) DUMAS, TX F: 1 SO 1596 00:11:27.55 05:43 10.5mph :"
            // Or multi-line:
            // "1 CHRISTIAN VALENZUELA MIDLAND, TX M: 1 JR 2818 00:17:26.91..."
            // "(MILE)"

            // Try single-line format first (team in parentheses on same line)
            let match = line.match(/^(\d+)\s+([A-Z\s]+)\s*\(([A-Z]{3,4})\)\s*(.+?)\s+([MF])R?:\s*\d+\s+(FR|SO|JR|SR|8th|\d{1,2}th)\s+(\d+)\s+([\d:\.]+)/i);

            if (match) {
                // Clean up time - remove leading "00:" if present
                let time = match[8].trim();
                if (time.startsWith('00:')) {
                    time = time.substring(3);
                }

                return {
                    place: match[1].trim(),
                    name: match[2].trim(),
                    team: match[3].trim(),
                    grade: match[6].trim().toUpperCase(),
                    bib: match[7].trim(),
                    time: time,
                    points: '',
                    pace: ''
                };
            }

            // Try multi-line format (team on next line)
            match = line.match(/^(\d+)\s+([A-Z\s]+)\s+(.+?)\s+([MF])R?:\s*\d+\s+(FR|SO|JR|SR|8th|\d{1,2}th)\s+(\d+)\s+([\d:\.]+)/i);

            if (match && nextLine) {
                const teamMatch = nextLine.match(/^\(([A-Z]{3,4})\)/i);
                if (teamMatch) {
                    // Clean up time - remove leading "00:" if present
                    let time = match[7].trim();
                    if (time.startsWith('00:')) {
                        time = time.substring(3);
                    }

                    return {
                        place: match[1].trim(),
                        name: match[2].trim(),
                        team: teamMatch[1].trim(),
                        grade: match[5].trim().toUpperCase(),
                        bib: match[6].trim(),
                        time: time,
                        points: '',
                        pace: ''
                    };
                }
            }

            return null;
        }

        function parseRunHighFormat(line) {
            // RunHigh format: "  ID#  POINTS  PLACE  Name, Grade  Split  Time  Pace  Team"
            // After trim: "1668     1     1  Gabe Simkiss, 11..."
            if (!line.match(/^\d{3,4}\s+/)) {
                return null;
            }
            
            let result = {
                place: '',
                points: '',
                bib: '',
                name: '',
                grade: '',
                team: '',
                time: '',
                pace: ''
            };
            
            // Split by multiple spaces (2 or more)
            const parts = line.trim().split(/\s{2,}/).map(p => p.trim()).filter(p => p);
            
            if (parts.length < 5) return null;
            
            let partIndex = 0;
            
            // ID# (bib number)
            if (partIndex < parts.length && parts[partIndex].match(/^\d{3,4}$/)) {
                result.bib = parts[partIndex];
                partIndex++;
            }
            
            // POINTS
            if (partIndex < parts.length && parts[partIndex].match(/^\d+$/)) {
                result.points = parts[partIndex];
                partIndex++;
            }
            
            // PLACE
            if (partIndex < parts.length && parts[partIndex].match(/^\d+$/)) {
                result.place = parts[partIndex];
                partIndex++;
            }
            
            // Name with grade - format "FirstName LastName, Grade" or "FirstName LastName, Grade*" (asterisk for females)
            if (partIndex < parts.length) {
                const namePart = parts[partIndex];
                const nameMatch = namePart.match(/^(.+),\s*(\d{1,2})\*?$/);
                if (nameMatch) {
                    result.name = nameMatch[1].trim();
                    result.grade = nameMatch[2];
                    partIndex++;
                } else {
                    result.name = namePart;
                    partIndex++;
                }
            }
            
            // Skip split time
            if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}:\d{2}\.\d+$/)) {
                partIndex++;
            }
            
            // Final time
            if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}:\d{2}\.\d+$/)) {
                result.time = parts[partIndex];
                partIndex++;
            }
            
            // Pace
            if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}:\d{2}$/)) {
                result.pace = parts[partIndex];
                partIndex++;
            }
            
            // Team name
            if (partIndex < parts.length) {
                result.team = parts.slice(partIndex).join(' ').trim();
            }
            
            return (result.place && result.name && result.time) ? result : null;
        }
        
        function parseKarmaRushTabFormat(lines, startIndex) {
            let i = startIndex;
            let result = {
                place: '',
                points: '',
                bib: '',
                name: '',
                grade: '',
                team: '',
                time: '',
                pace: ''
            };
            
            const firstLine = lines[i].trim();
            const tabParts = firstLine.split('\t').map(p => p.trim());
            
            if (tabParts.length < 2) {
                return null;
            }
            
            result.place = tabParts[0];
            result.name = tabParts[1];
            i++;
            
            if (i < lines.length) {
                const schoolLine = lines[i].trim();
                const match = schoolLine.match(/^(.+?)\s*\[(\d{1,2}|fr|so|jr|sr)\]\s*-\s*(\d+)$/i);
                if (match) {
                    result.team = match[1].trim();
                    result.grade = match[2];
                    result.bib = match[3];
                }
                i++;
            }
            
            if (i < lines.length && lines[i].match(/^\d{1,2}:\d{2}\.\d/)) {
                result.time = lines[i].trim();
                i++;
            }
            
            if (i < lines.length && lines[i].includes('|')) {
                i++;
            }
            
            let pointsCollected = 0;
            while (i < lines.length && pointsCollected < 2) {
                if (lines[i].trim().match(/^\d+$/)) {
                    if (!result.points) {
                        result.points = lines[i].trim();
                    }
                    i++;
                    pointsCollected++;
                } else {
                    break;
                }
            }
            
            return result.time ? { ...result, nextIndex: i } : null;
        }

        function parseMileSplitFormat(lines, startIndex) {
            let i = startIndex;
            let result = {
                place: '',
                points: '',
                bib: '',
                name: '',
                grade: '',
                team: '',
                time: '',
                pace: ''
            };
            
            const placeLine = lines[i].trim();
            if (!placeLine.match(/^(\d+|--)$/)) {
                return null;
            }
            
            result.place = placeLine;
            i++;
            
            if (i < lines.length && lines[i].trim().match(/^Logo/i)) {
                i++;
            }
            
            if (i < lines.length) {
                const nameLine = lines[i].trim();
                if (!nameLine.match(/^(\d+|--|Logo)$/i)) {
                    result.name = nameLine;
                    i++;
                } else {
                    return null;
                }
            }
            
            if (i < lines.length) {
                const teamLine = lines[i].trim();
                if (!teamLine.match(/^(\d+|--|Logo)$/i)) {
                    const bibMatch = teamLine.match(/#(\d+)/);
                    if (bibMatch) {
                        result.bib = bibMatch[1];
                        result.team = teamLine.replace(/-\s*#\d+/, '').trim();
                    } else {
                        result.team = teamLine;
                    }
                    i++;
                }
            }
            
            if (i < lines.length) {
                const timeLine = lines[i].trim();
                if (timeLine.match(/^\d{1,2}:\d{2}\.\d{1,2}$/) || timeLine === '--') {
                    result.time = timeLine;
                    i++;
                }
            }

            // Check for optional points field after time
            // Points field exists in some MileSplit formats but not in live results
            // If the line after time is a number, check what follows it:
            // - If followed by "Logo" or a name (letters), it's the next place number, not points
            // - Only treat as points if followed by something else (like a number or end of file)
            if (i < lines.length) {
                const nextLine = lines[i].trim();
                if ((nextLine.match(/^\d+$/) || nextLine === '--') && i + 1 < lines.length) {
                    const lookAhead = i + 1 < lines.length ? lines[i + 1].trim() : '';
                    // Don't treat as points if followed by Logo, a name, or another number
                    if (!lookAhead.match(/^Logo$/i) && !lookAhead.match(/^[A-Za-z]/)) {
                        result.points = nextLine;
                        i++;
                    }
                }
            }

            return result.name ? { ...result, nextIndex: i } : null;
        }

        function parseRunSignupFormat(lines, startIndex) {
            let i = startIndex;
            let result = {
                place: '',
                points: '',
                bib: '',
                name: '',
                grade: '',
                team: '',
                time: '',
                pace: ''
            };
            
            const placeLine = lines[i];
            const placeParts = placeLine.split(/\t/).filter(p => p);
            
            if (!placeParts[0] || !placeParts[0].match(/^\d+$/)) {
                return null;
            }
            
            result.place = placeParts[0];
            
            for (let j = 1; j < placeParts.length; j++) {
                const part = placeParts[j];
                if (part.match(/^\d+$/)) {
                    if (part.match(/^\d{3,4}$/) && !result.bib) {
                        result.bib = part;
                    } else if (!result.points) {
                        result.points = part;
                    }
                }
            }
            i++;
            
            if (i < lines.length && lines[i].match(/^[A-Z]$/)) {
                i++;
            }
            
            let firstName = '';
            let lastName = '';
            
            if (i < lines.length && lines[i].match(/^[A-Z][a-z]/)) {
                firstName = lines[i];
                i++;
            }
            
            if (i < lines.length && lines[i].match(/^[A-Z][a-z]/)) {
                lastName = lines[i];
                i++;
            }
            
            result.name = [firstName, lastName].filter(n => n).join(' ');
            
            if (i < lines.length && lines[i].includes('\t')) {
                const dataLine = lines[i];
                const parts = dataLine.split(/\t/).map(p => p.trim()).filter(p => p);
                
                let partIndex = 0;
                
                if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}$/)) {
                    const num = parseInt(parts[partIndex]);
                    if (num >= 7 && num <= 12) {
                        result.grade = parts[partIndex];
                        partIndex++;
                    }
                }
                
                let teamParts = [];
                while (partIndex < parts.length && !parts[partIndex].match(/^\d{1,2}:\d{2}/)) {
                    const part = parts[partIndex];
                    
                    if (!result.bib && part.match(/^\d{3,4}$/) && 
                        partIndex + 1 < parts.length && 
                        !parts[partIndex + 1].match(/^\d{1,2}:\d{2}/)) {
                        result.bib = part;
                    } else {
                        teamParts.push(part);
                    }
                    partIndex++;
                }
                
                let teamName = teamParts.join(' ');
                teamName = teamName.replace(/\s+\d+\s+\d+\s+\d+$/, '');
                teamName = teamName.replace(/\s+\d+\s+\d+$/, '');
                teamName = teamName.replace(/\s+\d+$/, '');
                teamName = teamName.replace(/\s*\([^)]*\)\s*$/, '');
                teamName = teamName.replace(/\s*<\s*\d+\s*Incomplete\s*\d*\s*$/, '');
                teamName = teamName.replace(/\s*<\s*\d+\s*$/, '');
                teamName = teamName.replace(/\s*>\s*\d*\s*$/, '');
                teamName = teamName.replace(/\s*>\s*$/, '');
                result.team = teamName.trim();
                
                if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}:\d{2}/)) {
                    result.time = parts[partIndex];
                }
                
                i++;
            }
            
            return result.name && result.time ? { ...result, nextIndex: i } : null;
        }

        function detectPlatform(text) {
            const lowerText = text.toLowerCase();
            if (lowerText.includes('karmarush')) return 'KarmaRush';
            if (lowerText.includes('milesplit') || text.includes('Logo') || text.match(/#\d+/)) return 'MileSplit';
            if (lowerText.includes('runsignup')) return 'RunSignup';
            if (lowerText.includes('runhigh') || text.match(/ID#\s+POINTS\s+FINISHER/)) return 'RunHigh';
            if (lowerText.includes('athlete guild') || lowerText.includes('athleteguild')) return 'Athlete Guild';
            if (lowerText.includes('vfp') || lowerText.includes('v fit productions')) return 'VFP';
            if (lowerText.includes('rcc timing')) return 'RCC Timing';

            // Check for RCC Timing format: Overall, Score, Bib, Name, Class (SR/JR/SO/FR), Time, Team
            if (text.match(/(SR|JR|SO|FR)\s+\d{2}:\d{2}:\d{2}\.\d/m) && text.match(/^1\s+/m)) return 'RCC Timing';

            // Check for Web Timer format: Position, Bib, Name, Time (00:HH:MM.S)
            if (text.match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d/m)) return 'Web Timer';

            // Check for VFP format: Place    Score    Bib    Name    Team    Grade    Time
            if (text.match(/^1(\t|\s{2,})(\(.*\)|\d+)(\t|\s{2,})\d{2,4}(\t|\s{2,})[A-Z]/m)) return 'VFP';

            // Check for Athlete Guild format: Name    Bib    Team    Rank    Time
            if (text.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d{2,4}(\t|\s{2,})[A-Z]/m)) return 'Athlete Guild';

            // Check for Endurance Splits format before other patterns
            if (text.match(/^\d+(\t|\s{2,})\d+(\t|\s{2,})\d{3,4}(\t|\s{2,})[A-Z]/m)) return 'Endurance Splits';

            if (text.match(/^\s+\d{3,4}\s+\d+\s+\d+\s+[A-Z][a-z]+.*,\s*\d{1,2}\s+\d{1,2}:\d{2}\.\d+/m)) return 'RunHigh';
            if (text.match(/\[\d{1,2}\] - \d{3,4}/)) return 'KarmaRush';
            if (text.match(/^\d{1,3}\s{2,}\d{2,4}\s{2,}/m)) return 'PDF';
            if (text.match(/\t.*\t.*\d{1,2}:\d{2}\.\d/)) return 'RunSignup';

            return 'Auto-detected';
        }

        function displayResults() {
            const tbody = document.getElementById('tableBody');
            
            if (extractedResults.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" class="empty-state">
                            <div class="empty-state-icon">üìã</div>
                            <div>No results yet. Paste race data above and click "Extract Results"</div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = extractedResults.map((r, index) => {
                // Check if this is a header row
                if (r.isHeader) {
                    return `
                        <tr class="race-header-row">
                            <td colspan="6" class="race-header">${r.headerText}</td>
                        </tr>
                    `;
                }

                let placeClass = 'place-cell';
                if (r.place === '1') placeClass += ' gold';
                else if (r.place === '2') placeClass += ' silver';
                else if (r.place === '3') placeClass += ' bronze';

                return `
                    <tr>
                        <td class="${placeClass}">${r.place}</td>
                        <td class="bib-cell">${r.bib}</td>
                        <td class="name-cell">${r.name}</td>
                        <td style="text-align: center;">${r.grade}</td>
                        <td class="team-cell">${r.team}</td>
                        <td class="time-cell">${r.time}</td>
                    </tr>
                `;
            }).join('');
        }

        function copyAsSpreadsheet() {
            if (extractedResults.length === 0) {
                showToast('No results to copy');
                return;
            }
            
            const delimiter = document.getElementById('delimiter').value === 'csv' ? ',' :
                            document.getElementById('delimiter').value === 'pipe' ? '|' : '\t';

            const header = ['Place', 'Bib', 'Name', 'Grade', 'Team', 'Time'].join(delimiter);
            const rows = extractedResults.map(r => {
                // If it's a header row, output the header text across all columns
                if (r.isHeader) {
                    return r.headerText;
                }
                return [r.place, r.bib, r.name, r.grade, r.team, r.time].join(delimiter);
            });

            const output = [header, ...rows].join('\n');
            
            copyToClipboard(output);
            showToast('Copied to clipboard!');
        }

        function copyTableData() {
            if (extractedResults.length === 0) {
                showToast('No results to copy');
                return;
            }
            
            const delimiter = '\t';

            const header = ['Place', 'Bib', 'Name', 'Grade', 'Team', 'Time'].join(delimiter);
            const rows = extractedResults.map(r => {
                // If it's a header row, output the header text across all columns
                if (r.isHeader) {
                    return r.headerText;
                }
                return [r.place, r.bib, r.name, r.grade, r.team, r.time].join(delimiter);
            });

            const output = [header, ...rows].join('\n');
            
            copyToClipboard(output);
            showToast('Table copied to clipboard!');
        }

        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }

        function clearAll() {
            document.getElementById('input').value = '';
            extractedResults = [];
            displayResults();
            document.getElementById('rowCount').textContent = '0';
            document.getElementById('platform').textContent = '-';
            document.getElementById('status').textContent = 'Ready';
            showToast('Cleared all data');
        }

        function loadSample() {
            const sampleData = `  ID#  POINTS        FINISHER          TIME       2.5K    
 1668     1     1  Gabe Simkiss, 11          8:11.2   16:13.7    5:14  Regina Luminis Acad.     
  509     2     2  Kendel Jones, 12          8:10.5   16:17.8    5:15  Elk Lake                 
  503     3     3  Cody Adams, 12            8:15.3   16:40.1    5:23  Elk Lake                 
 1720     4     4  Mikey Schimelfenig, 12    8:15.3   16:53.7    5:27  Riverside                
  512     5     5  Parker Upright, 11        8:19.1   16:58.5    5:29  Elk Lake`;
            
            document.getElementById('input').value = sampleData;
            showToast('Sample data loaded - click Extract Results');
        }
    </script>
</body>
</html>