<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Race Results Extractor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèÉ</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }
        
        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .input-section {
            margin-bottom: 20px;
        }
        
        .input-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }
        
        .input-area {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        .input-area:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .button-row {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #e0e0e0;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background: #38a169;
            transform: translateY(-2px);
        }
        
        .btn-warning {
            background: #ed8936;
            color: white;
        }
        
        .btn-warning:hover {
            background: #dd6b20;
        }
        
        .format-selector {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }
        
        .format-selector select {
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
        }
        
        .stats-bar {
            display: flex;
            gap: 30px;
            padding: 15px 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
        
        .stat-value {
            font-weight: 700;
            color: #333;
            font-size: 1.1em;
        }
        
        .table-container {
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .table-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .table-title {
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .table-wrapper {
            max-height: 600px;
            overflow-y: auto;
            overflow-x: auto;
        }
        
        .results-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }
        
        .results-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .results-table th {
            background: #f8f9fa;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #e0e0e0;
            white-space: nowrap;
        }
        
        .results-table tbody tr {
            transition: background-color 0.2s ease;
        }
        
        .results-table tbody tr:hover {
            background-color: #f8f9fa;
        }
        
        .results-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .results-table tbody tr:nth-child(even) {
            background-color: #fafbfc;
        }
        
        .place-cell {
            font-weight: 700;
            color: #667eea;
            text-align: center;
        }
        
        .place-cell.gold {
            color: #f6ad55;
        }
        
        .place-cell.silver {
            color: #a0aec0;
        }
        
        .place-cell.bronze {
            color: #ed8936;
        }

        .race-header-row {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .race-header {
            text-align: center;
            font-weight: 700;
            font-size: 1.1em;
            color: white;
            padding: 12px !important;
            letter-spacing: 0.5px;
        }

        .bib-cell {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #718096;
            text-align: center;
        }
        
        .name-cell {
            font-weight: 500;
            color: #2d3748;
        }
        
        .team-cell {
            color: #4a5568;
        }
        
        .time-cell {
            font-family: 'Monaco', 'Menlo', monospace;
            font-weight: 600;
            color: #2d3748;
        }
        
        .points-cell {
            text-align: center;
            font-weight: 600;
            color: #667eea;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #a0aec0;
        }
        
        .empty-state-icon {
            font-size: 3em;
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab-button {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: #666;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-button:hover {
            color: #333;
            background: #f8f9fa;
        }

        .tab-button.active {
            color: #007bff;
            border-bottom-color: #007bff;
        }

        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #48bb78;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            font-weight: 600;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .error-message {
            color: #e53e3e;
            background: #fff5f5;
            border: 1px solid #feb2b2;
            padding: 10px 15px;
            border-radius: 6px;
            margin-top: 10px;
            display: none;
        }
        
        .hidden {
            display: none;
        }
        
        .table-wrapper::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        .table-wrapper::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .table-wrapper::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 5px;
        }
        
        .table-wrapper::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Race Results Extractor</h1>
            <p>Transform messy race results into beautiful, organized data - supports KarmaRush, RunSignup, MileSplit, RunHigh, and GoChip</p>
        </header>

        <div class="control-panel">
            <div class="input-section">
                <label class="input-label">Paste Race Results Here</label>
                <textarea id="input" class="input-area" placeholder="Copy and paste race results from KarmaRush, RunSignup, MileSplit, RunHigh, or GoChip...

RunHigh Example:
  509     2     2  Kendel Jones, 12          8:10.5   16:17.8    5:15  Elk Lake

KarmaRush Example:
1	Travis Furmanski
Cedar Crest [12] - 4570
14:53.8

RunSignup Example:
1    1    
A
Ariana
Akey
12    251    Mountain Vista High School    20:00.8    6:27/M"></textarea>
                <div id="inputError" class="error-message"></div>
            </div>
            
            <div class="button-row">
                <button class="btn btn-primary" onclick="extractResults()">
                    Extract Results
                </button>
                <button class="btn btn-secondary" onclick="loadSample()">
                    Load Sample
                </button>
                <button class="btn btn-warning" onclick="clearAll()">
                    Clear All
                </button>
                <button class="btn btn-success" onclick="copyAsSpreadsheet()">
                    Copy for Excel
                </button>
                
                <div class="format-selector">
                    <label for="delimiter">Export Format:</label>
                    <select id="delimiter">
                        <option value="tab">Tab (Excel/Sheets)</option>
                        <option value="csv">CSV</option>
                        <option value="pipe">Pipe (|)</option>
                    </select>
                </div>
            </div>
            
            <div class="stats-bar">
                <div class="stat">
                    <span class="stat-label">Total Results:</span>
                    <span id="rowCount" class="stat-value">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Platform:</span>
                    <span id="platform" class="stat-value">-</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Status:</span>
                    <span id="status" class="stat-value">Ready</span>
                </div>
            </div>
        </div>

        <!-- Tab buttons for switching between views -->
        <div class="tabs" id="outputTabs" style="display: none;">
            <button class="tab-button active" onclick="switchTab('results')">Individual Results</button>
            <button class="tab-button" onclick="switchTab('teamScores')">Team Scores</button>
        </div>

        <!-- Individual Results Table -->
        <div class="table-container" id="resultsContainer">
            <div class="table-header">
                <div class="table-title">Extracted Results</div>
                <button class="btn btn-secondary" style="padding: 8px 16px;" onclick="copyTableData()">
                    Copy Table
                </button>
            </div>
            <div class="table-wrapper">
                <table class="results-table" id="resultsTable">
                    <thead>
                        <tr>
                            <th>Place</th>
                            <th>Bib</th>
                            <th>Name</th>
                            <th>Grade</th>
                            <th>Team</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <tr>
                            <td colspan="6" class="empty-state">
                                <div class="empty-state-icon">üìã</div>
                                <div>No results yet. Paste race data above and click "Extract Results"</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Team Scores Container -->
        <div class="table-container" id="teamScoresContainer" style="display: none;">
            <div class="table-header">
                <div class="table-title">Team Scores</div>
                <button class="btn btn-secondary" style="padding: 8px 16px;" onclick="copyTeamScores()">
                    Copy Team Scores
                </button>
            </div>
            <div class="table-wrapper">
                <pre id="teamScoresOutput" style="font-family: 'Courier New', monospace; padding: 20px; background: #f8f9fa; border-radius: 8px; overflow-x: auto; white-space: pre;">No team scores yet. Paste team scores data above and click "Extract Results"</pre>
            </div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        let extractedResults = [];
        let isTeamScoresMode = false;

        function switchTab(tab) {
            const resultsContainer = document.getElementById('resultsContainer');
            const teamScoresContainer = document.getElementById('teamScoresContainer');
            const tabButtons = document.querySelectorAll('.tab-button');

            if (tab === 'results') {
                resultsContainer.style.display = 'block';
                teamScoresContainer.style.display = 'none';
                tabButtons[0].classList.add('active');
                tabButtons[1].classList.remove('active');
            } else {
                resultsContainer.style.display = 'none';
                teamScoresContainer.style.display = 'block';
                tabButtons[0].classList.remove('active');
                tabButtons[1].classList.add('active');
            }
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function showError(message) {
            const errorEl = document.getElementById('inputError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, 5000);
        }

        function extractResults() {
            const input = document.getElementById('input').value;

            if (!input.trim()) {
                showError('Please paste race results into the input area');
                return;
            }

            document.getElementById('status').textContent = 'Processing...';
            extractedResults = [];

            try {
                const lines = input.trim().split('\n').map(line => line.trim()).filter(line => line);
                console.log('Total lines:', lines.length);
                
                // Skip header content - find where results actually start
                // First, look for "Individuals" section or the all-results header (RunHigh format)
                let individualsIndex = -1;
                let teamResultsEnd = -1;

                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].match(/^Individuals$/i) ||
                        lines[i].match(/ID#\s+POINTS/i) ||
                        lines[i].match(/ID#\s+PLACE\s+SCORE\s+FINISHER/i) ||
                        lines[i].match(/^Top$/i) ||
                        lines[i].match(/Place\s+Bib\s+Name/i) ||
                        lines[i].match(/Individual Results/i) ||
                        lines[i].match(/Place\s+Name\s+Grade\s+Team\s+Time/i)) {
                        individualsIndex = i;
                        break;
                    }

                    // RCC Timing: Skip "Team Overall Results" section
                    if (lines[i].match(/Team Overall Results|Team Results|Individual Overall Results/i)) {
                        // Find where team results end (look for first individual result line)
                        for (let j = i + 1; j < lines.length; j++) {
                            // Individual results have: Overall, Score, Bib, Name, Class, Time, Team
                            // Class can be SR/JR/SO/FR (high school) or 6th/7th/8th or 6/7/8 (middle school) or missing
                            if (lines[j].match(/^\d+\s+(\d+|\(?\d+\)?)\s+\d{2,5}\s+\w+.*\s+(SR|JR|SO|FR|[678]th?|1[0-2]th?)?\s+\d{2}:\d{2}:\d{2}\.\d/i)) {
                                teamResultsEnd = j;
                                individualsIndex = j;
                                break;
                            }
                        }
                        if (teamResultsEnd >= 0) break;
                    }
                }

                // Search for first data line (starting from Individuals section if found)
                const searchStart = individualsIndex >= 0 ? individualsIndex : 0;
                let startIndex = -1;

                for (let i = searchStart; i < lines.length; i++) {
                    const line = lines[i];
                    // River City Races format: "1 Carson Smith Air Academy High 1044 M 15:32.9"
                    // Pattern: Place, Name (first last), Team, Bib (3-4 digits), Gender (M/F), Time
                    if (line.match(/^1\s+[A-Z][a-z]+\s+[A-Z][a-z]+\s+[\w\s]+ +\d{3,4}\s+(M|F)\s+\d{1,2}:\d{2}\.\d/)) {
                        startIndex = i;
                        break;
                    }
                    // Tiffin format: "1 Andrew Seiverth 12 Perrysburg 17:35.4 1"
                    if (line.match(/^1\s+\w+\s+\w+\s+(7|8|9|10|11|12)\s+[\w\s.'-]+\s+\d{1,2}:\d{2}\.\d(\s+\d+)?\s*$/)) {
                        startIndex = i;
                        break;
                    }
                    // RaceDay Scoring format: "1    211    Teagan Kennedy        Maumee    1    36    1    00:18:03.10    5:49"
                    if (line.match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d+\s+\d{1,2}:\d{2}\s*$/)) {
                        startIndex = i;
                        break;
                    }
                    // Webscorer format: "1    7072    Boyd Hamby"
                    if (i + 2 < lines.length) {
                        const line1Parts = line.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);
                        if (line1Parts.length >= 3 &&
                            line1Parts[0] === '1' &&
                            line1Parts[1].match(/^\d{3,5}$/) &&
                            lines[i + 1].match(/^[A-Za-z\s]+-\s*\d{1,2}\s*$/) &&
                            lines[i + 2].match(/\d{1,2}:\d{2}\.\d{2}/)) {
                            startIndex = i;
                            break;
                        }
                    }
                    // Oklahoma format: "1 99 Tatum Penland 10 Bixby High School 1 00:19:15 6:12"
                    if (line.match(/^1\s+\d{1,5}\s+\w+\s+\w+\s+(9|10|11|12)\s+\w+.*\s+\d+\s+\d{2}:\d{2}/i)) {
                        startIndex = i;
                        break;
                    }
                    // RCC Timing: "1 1 353 Noah Bontrager SR 00:15:21.54 Westview"
                    // Middle school: "1 1 4788 Emmett Glenn 8th 00:10:11.64 Bellmont"
                    if (line.match(/(SR|JR|SO|FR|[678]th?|1[0-2]th?)\s+\d{2}:\d{2}:\d{2}\.\d/i) && line.match(/^1\s+/)) {
                        startIndex = i;
                        break;
                    }
                    // Web Timer: "1    889    Name    00:12:45.9..."
                    if (line.match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d/i)) {
                        startIndex = i;
                        break;
                    }
                    // VFP: "1 (< 5) 594 Name..." or "1 1 35 Name..." - has pace at end
                    if (line.match(/^1\s+(\d+|\(.*\)).*\d{1,2}:\d{2}\/M\s*$/i)) {
                        startIndex = i;
                        break;
                    }
                    // Runnercard: "1.    58    River Shaw    Jr    1.    Grand County HS    16:52.9    1"
                    if (line.match(/^1\.\s+\d{1,3}\s+\w+\s+\w+\s+(Fr|So|Jr|Sr)\s+\d+\.\s+[\w\s]+\s+\d{1,2}:\d{2}\.\d/i)) {
                        startIndex = i;
                        break;
                    }
                    // Competitive Timing format: "1    4244    Karee Cooley    11    Powell High School    1    41    2    18:34.88    6:00"
                    // Must have: Place=1, Bib (3-5 digits), Name, Year (9-12), Team, then time fields
                    // Key distinguisher: bib number (3-5 digits) after place, and year field
                    if (line.match(/^1(\t|\s{2,})\d{3,5}(\t|\s{2,})[A-Z][\w\s]+?(\t|\s{2,})(9|10|11|12)(\t|\s{2,})[A-Z][\w\s]+(\t|\s{2,})\d+(\t|\s{2,})\d+(\t|\s{2,})\d+(\t|\s{2,})\d{1,2}:\d{2}\.\d{2}(\t|\s{2,})\d{1,2}:\d{2}\s*$/i)) {
                        startIndex = i;
                        break;
                    }
                    // Race Roster format: "537    Banner Barnes    1    NOBLESVILLE    JR    1    1    4:52    15:03.7"
                    // Starts with bib number, then name
                    if (line.match(/^\d{1,4}(\t|\s{2,})[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d+(\t|\s{2,})[A-Z\s]+(\t|\s{2,})(FR|SO|JR|SR)(\t|\s{2,})/i)) {
                        startIndex = i;
                        break;
                    }
                    // Athlete Guild Format 1: "Name    Bib    Team    Rank    Time..."
                    // Athlete Guild Format 2: "Name    Bib    Place    Time    Pace    Team"
                    // Check for name pattern followed by bib number
                    if (line.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d{1,4}(\t|\s{2,})/i)) {
                        startIndex = i;
                        break;
                    }
                    // Endurance Splits: "1    1    1164    Name..."
                    if (line.match(/^1(\t|\s{2,})1(\t|\s{2,})\d{3,4}(\t|\s{2,})[A-Z]/i)) {
                        startIndex = i;
                        break;
                    }
                    // Space-delimited: "1 NAME (TEAM) ..." or multi-line with team on next line
                    if (line.match(/^1\s+[A-Z]+.*\([A-Z]{3,4}\)/i) ||
                        (line.match(/^1\s+[A-Z\s]+\s+[A-Z\s,]+\s+[MF]R?:/i) &&
                         i + 1 < lines.length &&
                         lines[i + 1].match(/^\([A-Z]{3,4}\)/i))) {
                        startIndex = i;
                        break;
                    }
                    // RunHigh: starts with whitespace and 3-4 digit number followed by more numbers
                    // Format: " 1668     1     1  Gabe Simkiss, 11..."
                    if (line.match(/^\s*\d{3,4}\s+\d+\s+\d+\s+\w/)) {
                        startIndex = i;
                        break;
                    }
                    // RCC Timing individual results: "1 1 353 Noah Bontrager SR 00:15:21.54 Westview"
                    if (line.match(/^1\s+\d+\s+\d{2,5}\s+\w+.*\s+(SR|JR|SO|FR)\s+\d{2}:\d{2}:\d{2}\.\d/i)) {
                        startIndex = i;
                        break;
                    }
                    // MileSplit format: "1" on its own line, followed by "Logo" and name
                    if (line.match(/^1$/) && i + 2 < lines.length) {
                        if (lines[i + 1].match(/^Logo$/i) &&
                            lines[i + 2].match(/^[A-Z]/)) {
                            startIndex = i;
                            break;
                        }
                    }
                    // GoChip format: "1" on its own line, followed by name, lap times, and "Chip:" line
                    // Example: "1" -> "Aiden Ready" -> "11:12.1" -> "23:17.1" -> "79Chip: C79Christian..."
                    if (line.match(/^1$/) && i + 4 < lines.length) {
                        // Check if next line is a name (starts with capital letter, not a number or "Logo")
                        if (lines[i + 1].match(/^[A-Z][a-z]+\s+[A-Z]/i) &&
                            // Check if there are time lines following
                            lines[i + 2].match(/^\d{1,2}:\d{2}\.\d/) &&
                            // Look for "Chip:" line in the next few lines
                            (lines[i + 3].match(/Chip:\s*[CE]\d+/i) ||
                             lines[i + 4].match(/Chip:\s*[CE]\d+/i))) {
                            startIndex = i;
                            break;
                        }
                    }
                    // RunSignup format: "1    580" (place + bib), followed by initial on next line
                    // Check if this line is "1" + bib number, and next few lines have the name pattern
                    if (line.match(/^1(\t|\s+)\d{3,4}$/) && i + 3 < lines.length) {
                        // Verify the pattern: initial, first name, last name
                        if (lines[i + 1].match(/^[A-Z]$/) &&
                            lines[i + 2].match(/^[A-Z][a-z]+$/) &&
                            lines[i + 3].match(/^[A-Z][a-z]+$/)) {
                            startIndex = i;
                            break;
                        }
                    }
                    // VFP format: Look for header line with "O'All Place" or column headers
                    // Data starts on the next line after the header
                    if (line.match(/(O'All\s+Place|^Place)(\t|\s{2,})Score(\t|\s{2,})Bib.*Name.*Team.*Time.*Pace/i)) {
                        startIndex = i + 1;
                        break;
                    }
                    // VFP format: data line with place, score, bib, and /M pace format
                    // Format: "1    (< 5)    4712    Noah Strohman    Holliday High School    4:44.4    9:35.2    14:40.0    14:40.0    4:42/M    12"
                    // Key: Score can be number or "(< 5)", has /M in pace, often has year at end
                    if (line.match(/^1(\t|\s+)(\d+|\(.*\))(\t|\s+)\d{3,4}(\t|\s+)[A-Z].*\d{1,2}:\d{2}\/M/)) {
                        startIndex = i;
                        break;
                    }
                    // HyTek format: Look for Event header or Name/Year/School header
                    // These headers appear before the individual results
                    // Header patterns: "Event 2 Boys 5k Run CC" or "Name Year School Finals Points"
                    // MUST CHECK BEFORE MeetPro since both use comma in name
                    if (line.match(/^Event\s+\d+\s+(Boys?|Girls?|Men|Women)/i) ||
                        line.match(/^Name\s+Year\s+School/i)) {
                        startIndex = i;
                        break;
                    }
                    // HyTek data line: Title Case name with comma (Last, First)
                    // Example: "1 Meyer, Josiah 10 Central Heights 17:23.10 1"
                    // Example: "36 McRoberts, Tristen 9 Central Heights 23:28.85"
                    // MeetPro uses UPPERCASE (MARTINEZ, Alek) - checked after this
                    // Team scores have no comma: "1 Central Heights 12 1 2 4 5 10 11 17"
                    // Time can have optional points after it
                    if (line.match(/^\d+\s+[A-Z][a-z]+,\s+[A-Z][a-z]+\s+([6-9]|1[0-2])\s+[\w\s]+?\s+\d{1,2}:\d{2}\.\d{1,2}/)) {
                        startIndex = i;
                        break;
                    }
                    // Athletic.net format: "1 Anna Prusak 12 Hathaway Brown 18:05.59 1"
                    // Pattern: Place, Name (First Last), Grade, Team, Time (MM:SS.SS), Points (optional)
                    // Check for header "PLACE VIDEO ATHLETE" or data line starting with "1 FirstName LastName Grade"
                    if (line.match(/^PLACE\s+VIDEO\s+ATHLETE\s+TEAM\s+MARK\s+POINTS/i)) {
                        startIndex = i + 1;
                        break;
                    }
                    // Check for data line: Must NOT have comma (to distinguish from HyTek)
                    if (line.match(/^1\s+[A-Z][a-z]+\s+[A-Z][a-z']+\s+([6-9]|1[0-2])\s+[\w\s.'-]+\s+\d{1,2}:\d{2}\.\d{2}/) && !line.includes(',')) {
                        startIndex = i;
                        break;
                    }
                    // KarmaRush format: line starting with "1" followed by name (not just "1" alone)
                    // Format: "1    Robert Mechura" or "1\tRobert Mechura"
                    // Must NOT have comma (to avoid matching HyTek/MeetPro)
                    // Note: Must come AFTER HyTek/MeetPro detection
                    if (line.match(/^1(\t|\s+)[A-Z][a-z]+\s+[A-Z]/) && !line.includes(',')) {
                        startIndex = i;
                        break;
                    }
                    // MeetPro format: Look for header line "Athlete YR # Team Score Time..."
                    // Data starts on the next line after the header
                    if (line.match(/^Athlete\s+YR\s+#\s+Team\s+Score\s+Time/i)) {
                        startIndex = i + 1;
                        break;
                    }
                    // MeetPro format: UPPERCASE LASTNAME, Firstname format
                    // Format: "25 MARTINEZ, Alek FR 1333 Hialeah Educational - 22:23.5..."
                    // Note: Uses ALL CAPS for last name (different from HyTek's Title Case)
                    if (line.match(/^\d+\s+[A-Z]{2,},\s+[A-Z]/)) {
                        startIndex = i;
                        break;
                    }
                    // RaceResult format: "1    1    226    Maya Easterwood    Coppell    5:13    5:40    6:12    17:06    5:30 / mi"
                    // Or: "1.    ~    1695    Jane Allen    Billings West    9    6:36    20:30"
                    // Pattern: Place, Points, Bib (1-4 digits), Name, Team, [Grade], [Pace], Time
                    // Key identifier: Bib comes BEFORE Name (distinguishes from MyRaceResult where bib comes after team)
                    // Points can be: number, "-", "~", "(n/s)", or "(number)"
                    // Place can be: "1" or "1."
                    if (line.match(/^1\.?(\t|\s{2,})(\d+|-|~|\(n\/s\)|\(\d+\))(\t|\s{2,})\d{1,4}(\t|\s{2,})[A-Z][a-z]+\s+[A-Z][\w\s]*(\t|\s{2,})[\w\s]+(\t|\s{2,})\d{1,2}:\d{2}/)) {
                        startIndex = i;
                        break;
                    }
                }

                if (startIndex === -1) {
                    // For team scores format, we don't need a traditional start index
                    // Check if this might be team scores data
                    // BUT: Check for BC Athletics first (which also has "Team Scores" but also "Individual Results")
                    const hasBCIndividualResults = lines.some(line => line.match(/^Individual Results$/i));
                    const hasBCEventHeader = lines.some(line => line.match(/^(Boys?|Girls?)\s+\d+k?\s+(Run|Meter Run)\s+CC/i));
                    const hasTeamScoresHeader = lines.some(line => line.match(/Team Scores$/i));
                    const hasSplitPattern = lines.some(line => line.match(/1-5 Split/i));

                    if (hasBCIndividualResults && hasBCEventHeader) {
                        // BC Athletics format - set startIndex to 0
                        console.log('Detected BC Athletics format, setting startIndex to 0');
                        startIndex = 0;
                    } else if (hasTeamScoresHeader || hasSplitPattern) {
                        console.log('Detected team scores format, setting startIndex to 0');
                        startIndex = 0;
                    } else {
                        console.log('Failed to find start index. Showing first 20 lines:');
                        for (let i = 0; i < Math.min(20, lines.length); i++) {
                            console.log(`Line ${i}:`, lines[i]);
                        }
                        showError('Could not find the start of race results. Make sure you copied the results table.');
                        document.getElementById('status').textContent = 'Error';
                        return;
                    }
                }

                console.log('Found start index:', startIndex, 'Line:', lines[startIndex]);

                // Check if this is RunSignup format (don't look backwards for headers in this case)
                const isRunSignupStart = lines[startIndex].match(/^\d+(\t|\s+)\d{3,4}$/) &&
                    startIndex + 3 < lines.length &&
                    lines[startIndex + 1].match(/^[A-Z]$/) &&
                    lines[startIndex + 2].match(/^[A-Z][a-z]+$/);

                // Look backwards from startIndex to find any race headers (skip for RunSignup)
                // Check up to 50 lines before for headers like "Varsity Girls - Overall" or "All Events" or "Race #X"
                // Need more lines for MeetPro since there's often team scoring summary before Individual Results
                if (!isRunSignupStart) {
                    let headerCheckStart = Math.max(0, startIndex - 50);
                    for (let i = startIndex - 1; i >= headerCheckStart; i--) {
                    // Competitive Timing format: look for headers with "Team Finish List"
                    // Pattern: "Varsity Girls Team Finish List-General"
                    if (lines[i].match(/team\s+finish\s+list/i) && lines[i].match(/(?:varsity|jv|boys?|girls?|men|women)/i)) {
                        startIndex = i;
                        break;
                    }
                    // Race Roster format: look for headers with "Individuals"
                    // Pattern: "Varsity Boys 5K - Individuals"
                    if (lines[i].match(/individuals/i) && lines[i].match(/(?:varsity|jv|boys?|girls?|men|women)/i)) {
                        startIndex = i;
                        break;
                    }
                    // MyRaceResult format: look for race name like "Boys Elite", "Girls Varsity", etc.
                    // These appear right before the column headers
                    if (lines[i].match(/^(Boys?|Girls?|Men|Women)\s+(Elite|Varsity|JV|Freshman|Sophomore|Junior|Senior)/i)) {
                        startIndex = i;
                        break;
                    }
                    // Athlete Guild format
                    if (lines[i].match(/^(Varsity|JV|7th Grade|8th Grade)\s+(Boys?|Girls?)\s+-\s+Overall$/i)) {
                        startIndex = i;
                        break;
                    }
                    // MileSplit format: look for "All Events" which precedes the event header
                    if (lines[i].match(/^All Events$/i)) {
                        startIndex = i;
                        break;
                    }
                    // MeetPro format: look for "Race #X" which precedes the race name
                    if (lines[i].match(/^Race\s+#\d+/i)) {
                        startIndex = i;
                        break;
                    }
                    }
                }

                const resultLines = lines.slice(startIndex);
                console.log('Result lines count:', resultLines.length);
                console.log('First 10 result lines:', resultLines.slice(0, 10));
                console.log('Lines around start index (40-55):', lines.slice(40, 55));

                // Debug: Look for name patterns
                const namePatternLines = lines.filter((line, idx) =>
                    line.match(/^[A-Z][a-z]+$/) && idx > startIndex && idx < startIndex + 50
                );
                console.log('Lines matching name pattern after start:', namePatternLines.slice(0, 10));

                // Try to detect format
                let hasKarmaRushPattern = false;
                let hasRunSignupPattern = false;
                let hasMileSplitPattern = false;
                let hasRunHighPattern = false;
                
                let hasSpaceDelimitedPattern = false;
                let hasEnduranceSplitsPattern = false;
                let hasAthleteGuildPattern = false;
                let hasVFPPattern = false;
                let hasWyoPrepsPattern = false;
                let hasRunnercardPattern = false;
                let hasWebTimerPattern = false;
                let hasRCCPattern = false;
                let hasOklahomaPattern = false;
                let hasWebscorerPattern = false;
                let hasRaceDayPattern = false;
                let hasTiffinPattern = false;
                let hasMeetProPattern = false;
                let hasMyRaceResultPattern = false;
                let hasRaceResultPattern = false;
                let hasRaceRosterPattern = false;
                let hasCompetitiveTimingPattern = false;
                let hasTeamScoresPattern = false;
                let hasRiverCityPattern = false;
                let hasHyTekPattern = false;
                let hasAthleticNetPattern = false;
                let hasGoChipPattern = false;
                let hasRMSPattern = false;
                let hasBCPattern = false;
                let hasColoradoPattern = false;

                // Check for BC Athletics format FIRST (before team scores)
                // BC Athletics has BOTH "Team Scores" AND "Individual Results" sections
                const hasBCIndividualResults = lines.some(line => line.match(/^Individual Results$/i));
                const hasBCEventHeader = lines.some(line => line.match(/^(Boys?|Girls?)\s+\d+k?\s+(Run|Meter Run)\s+CC/i));

                if (hasBCIndividualResults && hasBCEventHeader) {
                    console.log('BC Athletics format detected via Individual Results and event headers');
                    hasBCPattern = true;
                }

                // Check for Team Scores format by looking at ALL lines (not just resultLines)
                // because the header might be before the startIndex
                // Only match if we have BOTH the header AND the split pattern or the Place/Team/Points header
                // BUT: Skip if BC format was already detected
                if (!hasBCPattern) {
                    const hasTeamScoresHeader = lines.some(line => line.match(/Team Scores$/i));
                    const hasSplitPattern = resultLines.some(line => line.match(/\d+\+\d+\+\d+.*1-5 Split/i));
                    const hasTeamScoresColumns = resultLines.some(line => line.match(/^Place\s+Team\s+Points/i));

                    if ((hasTeamScoresHeader && hasSplitPattern) || hasTeamScoresColumns) {
                        console.log('Team Scores format detected via header or split pattern');
                        hasTeamScoresPattern = true;
                    }
                }

                for (let i = 0; i < Math.min(resultLines.length, 30); i++) {
                    if (i === 0) {
                        console.log('FORMAT DETECTION LOOP STARTED, checking', Math.min(resultLines.length, 30), 'lines');
                        console.log('First line for testing:', JSON.stringify(resultLines[0]));
                    }
                    // Competitive Timing format detection
                    // Pattern: Place, Bib, Name, Year, Team Name, Score, Team Score, Team Place, Clock Time, Pace
                    // Key identifier: Has "Team Finish List" in header and score column with special values like "< 5", "> 7", "(number)"
                    // Example: "1    4244    Karee Cooley    11    Powell High School    1    41    2    18:34.88    6:00"
                    const ctPattern = /^1(\t|\s{2,})\d{3,4}(\t|\s{2,})[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d{1,2}(\t|\s{2,})[A-Z][\w\s]+(\t|\s{2,})(\d+|<\s*\d+|>\s*\d+|\(\d+\))(\t|\s{2,})/;
                    if (resultLines[i].match(ctPattern)) {
                        console.log('Competitive Timing pattern matched at line', i, ':', resultLines[i]);
                        hasCompetitiveTimingPattern = true;
                        break;
                    }
                    // Race Roster format detection
                    // Pattern: Bib, Name, Overall Place, Team Name, Class, Team Place, Scoring Place, Pace, Time
                    // Key identifier: Has "Individuals" in header and bib at start of line
                    // Example: "537    Banner Barnes    1    NOBLESVILLE    JR    1    1    4:52    15:03.7"
                    if (resultLines[i].match(/^\d{1,4}(\t|\s{2,})[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d+(\t|\s{2,})[A-Z\s]+(\t|\s{2,})(FR|SO|JR|SR)(\t|\s{2,})\d+(\t|\s{2,})\d+(\t|\s{2,})\d{1,2}:\d{2}(\t|\s{2,})\d{1,2}:\d{2}\.\d/)) {
                        hasRaceRosterPattern = true;
                        break;
                    }
                    // VFP format: "Place Score Bib No Name Team Grade Time Pace"
                    // Pattern: starts with "1" followed by number/score, has pace like "6:04/M"
                    // Examples: "1 (< 5) 594 Name Team 9 12:08.84 6:04/M"
                    //           "1 1 35 Lionel Vargas MARTIN 10 16:55.0 5:27/M"
                    //           "1 1 4712 Noah Strohman Holliday 4:44.4 9:35.2 14:40.0 14:40.0 4:42/M 12"
                    // Pace can be at end or followed by year/grade
                    // IMPORTANT: Check BEFORE RaceResult since both formats have Place, Score, Bib pattern
                    // but VFP has /M in pace while RaceResult doesn't
                    // ALSO: Check for RMS first, since RMS also has /M in pace but has distinct footer
                    if (!lines.some(line => line.match(/Results By Race Management Systems/i)) &&
                        resultLines[i].match(/^1\s+(\d+|\(.*\)).*\d{1,2}:\d{2}\/M(\s|$)/i)) {
                        hasVFPPattern = true;
                        break;
                    }
                    // RaceResult format detection
                    // Pattern: Place, Points, Bib, Name, Team, ..., Time, Pace (tab or multi-space separated)
                    // Key identifier: Bib (1-4 digits) comes BEFORE Name
                    // Example: "1    1    226    Maya Easterwood    Coppell    5:13    5:40    6:12    17:06    5:30 / mi"
                    // Example: "1.    ~    1695    Jane Allen    Billings West    9    6:36    20:30"
                    // Points can be: number, "-", "~", "(n/s)", or "(number)"
                    // Place can be: "1" or "1."
                    // NOTE: VFP format is checked BEFORE this to avoid false matches (VFP has /M in pace)
                    if (resultLines[i].match(/^1\.?(\t|\s{2,})(\d+|-|~|\(n\/s\)|\(\d+\))(\t|\s{2,})\d{1,4}(\t|\s{2,})[A-Z][a-z]+\s+[A-Z][\w\s]*(\t|\s{2,})[\w\s]+(\t|\s{2,})\d{1,2}:\d{2}/)) {
                        console.log('RaceResult pattern matched at line', i, ':', resultLines[i]);
                        hasRaceResultPattern = true;
                        break;
                    }
                    // MyRaceResult format detection
                    // Pattern: Place, Points, Name, Team, Bib, Pace, Time (tab or multi-space separated)
                    // Key identifier: "Points" column between Place and Name
                    // Example: "1    1    Marcelo MANTECON    Belen Jesuit Prep    5086    4:41    14:33"
                    if (resultLines[i].match(/^1(\t|\s{2,})\d+(\t|\s{2,})[A-Z][a-z]+\s+[A-Z]+(\t|\s{2,})[\w\s]+(\t|\s{2,})\d{3,5}(\t|\s{2,})\d{1,2}:\d{2}(\t|\s{2,})\d{1,2}:\d{2}/)) {
                        hasMyRaceResultPattern = true;
                        break;
                    }
                    // MeetPro format detection: Look for "Race #X" followed by race name and "Final Results"
                    // This pattern appears at the start of every MeetPro race section
                    if (resultLines[i].match(/^Race\s+#\d+/i)) {
                        hasMeetProPattern = true;
                        break;
                    }
                    // Also check for LASTNAME, Firstname format as fallback
                    if (resultLines[i].match(/[A-Z]+,\s+[A-Z]/i)) {
                        hasMeetProPattern = true;
                        break;
                    }
                    // Tiffin format: "1 Andrew Seiverth 12 Perrysburg 17:35.4 1"
                    // Pattern: Place, Name, Grade (7-12), Team, Time (MM:SS.S), Points (optional)
                    // Key: Single-space separated with MM:SS.S time format (1 decimal)
                    if (resultLines[i].match(/^1\s+\w+\s+\w+\s+(7|8|9|10|11|12)\s+[\w\s.'-]+\s+\d{1,2}:\d{2}\.\d(\s+\d+)?\s*$/)) {
                        hasTiffinPattern = true;
                        break;
                    }
                    // RaceDay Scoring format: "1    211    Teagan Kennedy        Maumee    1    36    1    00:18:03.10    5:49"
                    // Pattern: Place, Bib, Name, Year, Team, Score, TeamScore, TeamPlace, Time (HH:MM:SS.XX), Pace
                    // Key identifier: Has pace at end (M:SS format) AND time with HH:MM:SS format
                    if (resultLines[i].match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d+\s+\d{1,2}:\d{2}\s*$/)) {
                        hasRaceDayPattern = true;
                        break;
                    }
                    // Webscorer format: 3 lines per runner
                    // Line 1: "1    7072    Boyd Hamby"
                    // Line 2: "Mcloud - 12"
                    // Line 3: "High School Boys    M    16:49.62    -"
                    if (i + 2 < resultLines.length) {
                        const line1Parts = resultLines[i].split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);
                        if (line1Parts.length >= 3 &&
                            line1Parts[0] === '1' &&
                            line1Parts[1].match(/^\d{3,5}$/) &&
                            resultLines[i + 1].match(/^[A-Za-z\s]+-\s*\d{1,2}\s*$/) &&
                            resultLines[i + 2].match(/\d{1,2}:\d{2}\.\d{2}/)) {
                            hasWebscorerPattern = true;
                            break;
                        }
                    }
                    // Oklahoma format: "1 99 Tatum Penland 10 Bixby High School 1 00:19:15 6:12"
                    // Pattern: Place, Bib, Name, Grade (9-12), Team, Score, Time, Pace
                    if (resultLines[i].match(/^1\s+\d{1,5}\s+\w+\s+\w+\s+(9|10|11|12)\s+\w+.*\s+\d+\s+\d{2}:\d{2}:\d{2}?\s+\d{1,2}:\d{2}/i)) {
                        hasOklahomaPattern = true;
                        break;
                    }
                    // RCC Timing format: "1 1 353 Noah Bontrager SR 00:15:21.54 Westview"
                    // Middle school: "1 1 4788 Emmett Glenn 8th 00:10:11.64 Bellmont"
                    // Pattern: Overall, Score, Bib, Name, Class (SR/JR/SO/FR or 6th/7th/8th or 6/7/8 or missing), Time, Team
                    // Key: Starts with place, score, bib (3 numbers) before name
                    if (resultLines[i].match(/^1[\s\t]+\d+[\s\t]+\d+[\s\t]+\w+.*(SR|JR|SO|FR|[678]th?|1[0-2]th?)[\s\t]+\d{2}:\d{2}:\d{2}\.\d/i)) {
                        hasRCCPattern = true;
                        break;
                    }
                    // Web Timer format: "1    889    Name    00:12:45.9    All Ages    1    Female..."
                    // Pattern: Place, Bib, Name, Time (00:HH:MM.S format)
                    if (resultLines[i].match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d/i)) {
                        hasWebTimerPattern = true;
                        break;
                    }
                    // WyoPreps format: "Place    Bib    Name    Year    Team Name    Score    Team Score    Team Place    Clock Time    Pace"
                    // Pattern: 4-digit bib, grade (9-12), time (MM:SS.S), pace without /M (M:SS)
                    // Example: "1    3677    Raina Wachob    10    Cody High School    1    19    1    20:59.7    6:46"
                    // Key: Has pace at end (M:SS) without /M suffix, time is MM:SS.S, score can be "(7)" or "> 7"
                    if (resultLines[i].match(/^1\s+\d{4}\s+\w+\s+\w+\s+(9|10|11|12)\s+.*\s+\d{1,2}:\d{2}\.\d\s+\d{1,2}:\d{2}\s*$/)) {
                        hasWyoPrepsPattern = true;
                        break;
                    }
                    // Runnercard format: "Place.    Bib    Name    Year    Team    Time    Score"
                    // Pattern: Place with period, bib (1-3 digits), name, year (Fr/So/Jr/Sr), team (starts with team place), time (MM:SS.S)
                    // Example: "1.    58    River Shaw    Jr    1.    Grand County HS    16:52.9    1"
                    // Key: Place ends with period, team field starts with number followed by period
                    if (resultLines[i].match(/^1\.\s+\d{1,3}\s+\w+\s+\w+\s+(Fr|So|Jr|Sr)\s+\d+\.\s+[\w\s]+\s+\d{1,2}:\d{2}\.\d/i)) {
                        hasRunnercardPattern = true;
                        break;
                    }
                    // Athlete Guild format: "Name    Bib    Team    Rank    Chip Time    Pace"
                    // Or: "Name    Bib    Place    Time    Pace    Team"
                    // Pattern: Name (two words), Bib (1-4 digits), then either team name or place number
                    if (resultLines[i].match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d{1,4}(\t|\s{2,})/i)) {
                        hasAthleteGuildPattern = true;
                        break;
                    }
                    // Endurance Splits format: "1    1    1164    Sofia Lauren Garza    Mission Sharyland    18:18.8    5:54/M"
                    if (resultLines[i].match(/^\d+(\t|\s{2,})\d+(\t|\s{2,})\d{3,4}(\t|\s{2,})[A-Z]/i)) {
                        hasEnduranceSplitsPattern = true;
                        break;
                    }
                    // Space-delimited format: "1 EMILY GROSS (DUMA) DUMAS, TX F: 1 SO 1596 00:11:27.55..."
                    if (resultLines[i].match(/^\d+\s+[A-Z]+.*\([A-Z]{3,4}\).*[MF]R?:\s*\d+\s+(FR|SO|JR|SR|8th)/i)) {
                        hasSpaceDelimitedPattern = true;
                        break;
                    }
                    // Multi-line space-delimited: team on next line
                    if (resultLines[i].match(/^\d+\s+[A-Z\s]+\s+[A-Z\s,]+\s+[MF]R?:\s*\d+\s+(FR|SO|JR|SR|8th)/i) &&
                        i + 1 < resultLines.length &&
                        resultLines[i + 1].match(/^\([A-Z]{3,4}\)/i)) {
                        hasSpaceDelimitedPattern = true;
                        break;
                    }
                    // RunHigh: Look for pattern with ID# at start followed by place/score and name
                    // Format: " 1668     1     1  Gabe Simkiss, 11          8:11.2   16:13.7..."
                    if (resultLines[i].match(/^\d{3,4}\s+\d+\s+\d+\s+[A-Z]/i)) {
                        hasRunHighPattern = true;
                        break;
                    }
                    // KarmaRush
                    if (resultLines[i].match(/\[(\d{1,2}|fr|so|jr|sr)\]\s*-\s*\d+/i)) {
                        hasKarmaRushPattern = true;
                        break;
                    }
                    // MileSplit - but not MeetPro (which also has bib numbers)
                    // MileSplit has "Logo" lines or standalone bib numbers on their own line
                    // MeetPro has bib numbers in the same line as the athlete data
                    if (resultLines[i].match(/^Logo$/i) ||
                        (resultLines[i].match(/^#\d+$/) || resultLines[i].match(/-\s*#\d+$/))) {
                        hasMileSplitPattern = true;
                        break;
                    }
                    // RunSignup
                    if (resultLines[i].match(/^[A-Z]$/) && i + 2 < resultLines.length &&
                        resultLines[i+1].match(/^[A-Z][a-z]+$/) &&
                        resultLines[i+2].match(/^[A-Z][a-z]+$/)) {
                        hasRunSignupPattern = true;
                        break;
                    }
                    // River City Races format detection
                    // Pattern: Place, Name (first last), Team (variable), Bib (3-4 digits), Gender (M/F), Time
                    // Example: "1 Carson Smith Air Academy High 1044 M 15:32.9"
                    // Key identifier: Ends with M or F followed by time
                    if (resultLines[i].match(/^1\s+[A-Z][a-z]+\s+[A-Z][a-z]+\s+[\w\s]+ +\d{3,4}\s+(M|F)\s+\d{1,2}:\d{2}\.\d/)) {
                        hasRiverCityPattern = true;
                        break;
                    }
                    // HyTek format detection
                    // Pattern: Place, Name (Last, First), Grade, Team, Time (with 2 decimals), Points (optional)
                    // Example: "1 Meyer, Josiah 10 Central Heights 17:23.10 1"
                    // Example: "36 McRoberts, Tristen 9 Central Heights 23:28.85"
                    // Key identifiers: LASTNAME, format and Name/Year/School/Finals headers or Results - Men/Women
                    // Check for the characteristic header pattern OR the data pattern with comma in name
                    if (resultLines[i].match(/^(Name\s+Year\s+School|Results\s+-\s+(Men|Women)|Event\s+\d+\s+(Boys?|Girls?))/i) ||
                        resultLines[i].match(/^\d+\s+[A-Z][a-z]+,\s+[A-Z][a-z]+\s+([6-9]|1[0-2])\s+[\w\s]+\s+\d{1,2}:\d{2}\.\d{1,2}/)) {
                        hasHyTekPattern = true;
                        break;
                    }
                    // Athletic.net format detection
                    // Pattern: Place, Name (First Last), Grade, Team, Time (MM:SS.SS), Points (optional)
                    // Example: "1 Anna Prusak 12 Hathaway Brown 18:05.59 1"
                    // Example: "15 Tillie O'donnell 12 Will. South 20:02.07" (no points)
                    // Key identifiers: No bib, no comma in name, grade after name, no /M in time
                    // Check for header "PLACE VIDEO ATHLETE TEAM MARK POINTS" OR data pattern
                    if (resultLines[i].match(/^PLACE\s+VIDEO\s+ATHLETE\s+TEAM\s+MARK\s+POINTS/i) ||
                        resultLines[i].match(/^\d+\s+[A-Z][a-z]+\s+[A-Z][a-z']+\s+([6-9]|1[0-2])\s+[\w\s.'-]+\s+\d{1,2}:\d{2}\.\d{2}/)) {
                        hasAthleticNetPattern = true;
                        break;
                    }
                    // GoChip format detection
                    // Multi-line format: Place, Name, Lap times, then "BibChip: CXXSchool"
                    // Example: "79Chip: C79Christian Homelearners Estreams"
                    // Key identifier: Line containing "Chip: C" or "Chip: E" followed by digits/letters
                    if (resultLines[i].match(/^\d+Chip:\s*[CE]\d+/i)) {
                        hasGoChipPattern = true;
                        break;
                    }
                    // Colorado format detection
                    // Pattern: Place Name (TEAM) Grade Time
                    // Example: "1            RILEY COLE (CHEYENNE MOUNTAIN HIG)                    SR            00:18:07.63"
                    // Can be tab-delimited: "1\t\t\tRILEY COLE (CHEYENNE MOUNTAIN HIG)\t\t\t\t\tSR\t\t\t00:18:07.63"
                    // Key identifiers:
                    //   - ALL CAPS names (FIRST LAST format)
                    //   - Team/school in parentheses
                    //   - Grade (FR/SO/JR/SR)
                    //   - Time format: HH:MM:SS.SS with leading zeros
                    if (i < 3) {
                        console.log('Testing Colorado pattern on line', i);
                        console.log('  Line content:', JSON.stringify(resultLines[i]));
                        console.log('  Has ALL CAPS name:', /[A-Z]{2,}\s+[A-Z]{2,}/.test(resultLines[i]));
                        console.log('  Has paren team:', /\([^)]+\)/.test(resultLines[i]));
                        console.log('  Has grade:', /(FR|SO|JR|SR)/.test(resultLines[i]));
                        console.log('  Has time:', /\d{2}:\d{2}:\d{2}\.\d{2}/.test(resultLines[i]));
                        console.log('  Pattern test 1:', /^\d+[\s\t]+[A-Z]/.test(resultLines[i]));
                        console.log('  Pattern test 2:', /^\d+[\s\t]+[A-Z][A-Z\s'-]+/.test(resultLines[i]));
                        console.log('  Pattern test 3:', /^\d+[\s\t]+[A-Z][A-Z\s'-]+\(/.test(resultLines[i]));
                        console.log('  Pattern test 4:', /^\d+[\s\t]+[A-Z][A-Z\s'-]+\([^)]+\)/.test(resultLines[i]));
                        console.log('  Full pattern match:', /^\d+[\s\t]+[A-Z][A-Z\s'-]+\([^)]+\)[\s\t]+(FR|SO|JR|SR)[\s\t]+\d{2}:\d{2}:\d{2}\.\d{2}/.test(resultLines[i]));
                    }
                    if (resultLines[i].match(/^\d+[\s\t]+[A-Z][A-Z\s'-]+\([^)]+\)[\s\t]+(FR|SO|JR|SR)[\s\t]+\d{2}:\d{2}:\d{2}\.\d{2}/)) {
                        console.log('Colorado pattern matched at line', i, ':', resultLines[i]);
                        hasColoradoPattern = true;
                        break;
                    }
                    // Race Management Systems (RMS) format detection
                    // Pattern: Place Score Bib No Name Team Grade Time Pace [Class] [Qualifier]
                    // Example: "1 1 684 Cooper Ratliff Mason 11 17:13.64 5:33/M TM"
                    // Example: "3 (< 5) 247 Colton Vrazel Danbury 12 17:17.93 5:35/M IND"
                    // Key identifiers:
                    //   - Footer: "Results By Race Management Systems, Inc."
                    //   - Header: "Overall Finish List"
                    //   - Score can be number or "(< 5)"
                    //   - Pace format: "M:SS/M"
                    // Check footer signature first
                    if (lines.some(line => line.match(/Results By Race Management Systems/i))) {
                        console.log('RMS footer signature found');
                        // Look for data pattern: Place, Score (or "< 5"), Bib, Name, Team, Grade, Time, Pace
                        // Check any line that has the RMS data pattern (not just starting with "1")
                        if (resultLines[i].match(/^\d+\s+(\d+|\(<?\s*\d+\))\s+\d{3,4}\s+\w+.*\d{1,2}:\d{2}\.\d+\s+\d{1,2}:\d{2}\/M/i)) {
                            console.log('RMS pattern matched at line', i, ':', resultLines[i]);
                            hasRMSPattern = true;
                            break;
                        }
                    }
                }

                // Debug: Log which patterns are detected
                console.log('Pattern detection complete:',
                    'BC=' + hasBCPattern,
                    'Colorado=' + hasColoradoPattern,
                    'TeamScores=' + hasTeamScoresPattern,
                    'CompTiming=' + hasCompetitiveTimingPattern,
                    'RaceRoster=' + hasRaceRosterPattern);

                if (hasCompetitiveTimingPattern) {
                    // Process Competitive Timing format
                    // Look for race headers like "Varsity Girls Team Finish List"
                    let lastHeaderCandidate = null;

                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check for race headers with "Team Finish List" keyword
                        // Pattern: "Varsity Girls Team Finish List-General"
                        if (line &&
                            line.match(/team\s+finish\s+list/i) &&
                            line.match(/(?:varsity|jv|boys?|girls?|men|women)/i) &&
                            line.length < 100) {
                            // Store as candidate, add it before first result
                            // Remove "Team Finish List-General" suffix
                            lastHeaderCandidate = line
                                .replace(/\s+team\s+finish\s+list.*$/i, '')
                                .trim();
                        } else {
                            let result = parseCompetitiveTimingFormat(line);
                            if (result) {
                                // If we have a header candidate and we're parsing actual results, add the header first
                                if (lastHeaderCandidate) {
                                    extractedResults.push({
                                        isHeader: true,
                                        headerText: lastHeaderCandidate.toUpperCase(),
                                        place: '',
                                        bib: '',
                                        name: '',
                                        team: '',
                                        time: '',
                                        grade: '',
                                        points: '',
                                        pace: ''
                                    });
                                    lastHeaderCandidate = null;
                                }
                                extractedResults.push(result);
                            }
                        }
                    }
                } else if (hasRaceRosterPattern) {
                    // Process Race Roster format
                    // Look for race headers like "Varsity Boys 5K - Individuals"
                    let lastHeaderCandidate = null;
                    let raceDistance = null;

                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check for race headers with "Individuals" keyword
                        // Pattern: "Varsity Boys 5K - Individuals" or similar
                        if (line &&
                            line.match(/individuals/i) &&
                            line.match(/(?:varsity|jv|boys?|girls?|men|women)/i) &&
                            line.length < 100) {
                            // Store as candidate, add it before first result
                            // Replace "5K" with "5km run" and remove " - Individuals"
                            lastHeaderCandidate = line
                                .replace(/\b5K\b/gi, '5km run')
                                .replace(/\s*-?\s*individuals?\s*$/i, '');
                            raceDistance = null; // Already in header
                        } else {
                            let result = parseRaceRosterFormat(line);
                            if (result) {
                                // If we have a header candidate and we're parsing actual results, add the header first
                                if (lastHeaderCandidate) {
                                    extractedResults.push({
                                        isHeader: true,
                                        headerText: lastHeaderCandidate.toUpperCase(),
                                        place: '',
                                        bib: '',
                                        name: '',
                                        team: '',
                                        time: '',
                                        grade: '',
                                        points: '',
                                        pace: ''
                                    });
                                    lastHeaderCandidate = null;
                                }
                                extractedResults.push(result);
                            }
                        }
                    }
                } else if (hasColoradoPattern) {
                    // Process Colorado format
                    console.log('Processing Colorado format');

                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseColoradoFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                    console.log('Colorado parsing complete, extracted', extractedResults.length, 'results');
                } else if (hasBCPattern) {
                    // Process BC Athletics format
                    console.log('Processing BC Athletics format');

                    // Look for race headers like "Boys 4k Run CC Junior 4000m"
                    let lastHeaderCandidate = null;

                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check for event headers
                        // Pattern: "Boys 4k Run CC Junior 4000m", "Girls 5k Run CC Senior 5000m"
                        if (line &&
                            line.match(/^(Boys?|Girls?)\s+\d+k?\s+(Run|Meter Run)\s+CC/i) &&
                            line.length < 100) {
                            // Store as candidate, add it before first result
                            lastHeaderCandidate = line;
                        } else if (line && line.match(/^Individual Results$/i)) {
                            // Skip "Individual Results" header line
                            continue;
                        } else {
                            let result = parseBCFormat(line);
                            if (result) {
                                // If we have a header candidate and we're parsing actual results, add the header first
                                if (lastHeaderCandidate) {
                                    extractedResults.push({
                                        isHeader: true,
                                        headerText: lastHeaderCandidate.toUpperCase(),
                                        place: '',
                                        bib: '',
                                        name: '',
                                        team: '',
                                        time: '',
                                        grade: '',
                                        points: '',
                                        pace: ''
                                    });
                                    lastHeaderCandidate = null;
                                }
                                extractedResults.push(result);
                            }
                        }
                    }
                    console.log('BC Athletics parsing complete, extracted', extractedResults.length, 'results');
                } else if (hasTeamScoresPattern) {
                    // Process Team Scores format (MileSplit team scores - not individual results)
                    // Format: Race name with "Team Scores", then Place/Team/Points/Scorers/Times data
                    // Use full lines array, not resultLines, since header may be before startIndex
                    let i = 0;
                    while (i < lines.length) {
                        const line = lines[i].trim();

                        // Check for team scores header line
                        // Pattern: "Girls 2 Mile Run Finals Team Scores"
                        if (line.match(/Team Scores$/i)) {
                            // Extract race name and normalize
                            let raceHeader = line.replace(/\s*Team Scores$/i, '').trim();
                            raceHeader = raceHeader
                                .replace(/\b5k\b/gi, '5km')
                                .replace(/\b5000m\b/gi, '5km')
                                .replace(/\b(\d+)\s*mile\b/gi, '$1 Mile')
                                .replace(/\s*Finals?\s*/gi, ' ');

                            // Add race header
                            extractedResults.push({
                                isHeader: true,
                                headerText: raceHeader.toUpperCase().trim(),
                                place: '',
                                bib: '',
                                name: '',
                                team: '',
                                time: '',
                                grade: '',
                                points: '',
                                pace: ''
                            });

                            // Add column header row
                            extractedResults.push({
                                isHeader: true,
                                headerText: 'PLACE\tTEAM\tPOINTS',
                                place: '',
                                bib: '',
                                name: '',
                                team: '',
                                time: '',
                                grade: '',
                                points: '',
                                pace: ''
                            });

                            i++;

                            // Skip column header lines (Place, Team, Points, Scorers, Times)
                            while (i < lines.length &&
                                   lines[i].trim().match(/^(Place|Team|Points?|Scorers?|Times?)/i)) {
                                i++;
                            }

                            // Parse team entries
                            while (i < lines.length) {
                                const teamLine = lines[i].trim();

                                // Stop at empty line or next race
                                if (!teamLine || teamLine.match(/Team Scores$/i)) {
                                    break;
                                }

                                // Check if this is a place number
                                if (teamLine.match(/^\d+$/)) {
                                    const place = teamLine;
                                    i++;

                                    // Next line(s) contain team name (might be duplicated)
                                    let teamName = '';
                                    if (i < lines.length) {
                                        teamName = lines[i].trim();
                                        i++;
                                        // Skip duplicate team name if present
                                        if (i < lines.length && lines[i].trim() === teamName) {
                                            i++;
                                        }
                                    }

                                    // Next line contains points and scoring info
                                    let points = '';
                                    if (i < lines.length) {
                                        const scoreLine = lines[i].trim();
                                        const pointsMatch = scoreLine.match(/^(\d+)/);
                                        if (pointsMatch) {
                                            points = pointsMatch[1];
                                        }
                                        i++;
                                    }

                                    // Add team score entry
                                    if (teamName && points) {
                                        extractedResults.push({
                                            isHeader: false,
                                            headerText: '',
                                            place: place,
                                            bib: '',
                                            name: '',
                                            team: teamName,
                                            time: points,
                                            grade: '',
                                            points: points,
                                            pace: ''
                                        });
                                    }
                                } else {
                                    i++;
                                }
                            }
                        } else {
                            i++;
                        }
                    }
                } else if (hasMyRaceResultPattern) {
                    // Process MyRaceResult format
                    // Look for race headers like "Boys Elite" or "Girls Varsity"
                    let lastHeaderCandidate = null;
                    let raceDistance = null;

                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check for race headers (e.g., "Boys Elite", "Girls Varsity")
                        // Pattern: contains "boys" or "girls" and is a short line without data structure
                        if (line &&
                            line.match(/(?:boys|girls|men|women|elite|varsity|jv)/i) &&
                            !line.includes('\t') &&
                            !line.match(/^\d+\s/) &&
                            !line.match(/^(Place|Points|Name|Team|Bib|Pace|Time|Number of records)/i) &&
                            line.length < 50) {
                            // Store as candidate, add it before first result
                            lastHeaderCandidate = line;
                            raceDistance = null; // Reset distance for new race
                        } else {
                            let result = parseMyRaceResultFormat(line);
                            if (result) {
                                // If we have a header candidate and we're parsing actual results, add the header first
                                if (lastHeaderCandidate) {
                                    // Calculate race distance from first result if we have pace
                                    if (!raceDistance && result.pace && result.time) {
                                        raceDistance = calculateRaceDistance(result.pace, result.time);
                                    }

                                    let headerText = lastHeaderCandidate.toUpperCase();
                                    if (raceDistance) {
                                        headerText += ` ${raceDistance}`;
                                    }

                                    extractedResults.push({
                                        isHeader: true,
                                        headerText: headerText,
                                        place: '',
                                        bib: '',
                                        name: '',
                                        team: '',
                                        time: '',
                                        grade: '',
                                        points: '',
                                        pace: ''
                                    });
                                    lastHeaderCandidate = null;
                                }
                                extractedResults.push(result);
                            }
                        }
                    }
                } else if (hasMeetProPattern) {
                    // Process MeetPro format
                    let lastHeaderCandidate = null;
                    let justSawRaceNumber = false;

                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check if this is a "Race #X" line followed by a race name
                        if (line.match(/^Race\s+#\d+/i) && i + 1 < resultLines.length) {
                            const nextLine = resultLines[i + 1].trim();
                            // Check if next line is a race header (contains boys/girls/varsity/jv)
                            if (nextLine &&
                                nextLine.match(/(?:boys|girls|men|women|varsity|jv)/i) &&
                                !nextLine.includes('\t') &&
                                !nextLine.match(/^\d+\s{2,}/) &&
                                !nextLine.match(/^(Place|Athlete|Individual|Team|Final|Yr\.|#|Score|Time|Gap|Avg|Start Time|Conditions|Temperature|Winds)/i) &&
                                nextLine.length < 50) {
                                // This is a race header - add it immediately
                                extractedResults.push({
                                    isHeader: true,
                                    headerText: nextLine.toUpperCase(),
                                    place: '',
                                    bib: '',
                                    name: '',
                                    team: '',
                                    time: '',
                                    grade: '',
                                    points: '',
                                    pace: ''
                                });
                                // Clear any previous header candidate since we just added the real header
                                lastHeaderCandidate = null;
                                i++; // Skip the next line since we just processed it
                                continue;
                            }
                        }

                        // Check for race headers (e.g., "JV Boys", "Girls Varsity", "Boys Varsity", "1A 2A JV Boys", "MS Boys 3000")
                        // Pattern: contains "boys" or "girls" or "varsity" or "jv" and is a short line without data structure
                        // Also skip table header lines like "Individual Results", "Athlete", etc.
                        // But don't store it as a candidate if we just processed a "Race #X" header
                        if (line &&
                            line.match(/(?:boys|girls|men|women|varsity|jv)/i) &&
                            !line.includes('\t') &&
                            !line.match(/^\d+\s{2,}/) &&
                            !line.match(/^(Place|Athlete|Individual|Team|Final|Yr\.|#|Score|Time|Gap|Avg|Start Time|Conditions|Temperature|Winds)/i) &&
                            line.length < 50 &&
                            // Don't treat this as a candidate if it was just added as part of Race #X
                            // or if any existing header already contains this text
                            !extractedResults.some(r => r.isHeader && (r.headerText === line.toUpperCase() || r.headerText.includes(line.toUpperCase())))) {
                            // Store as candidate, don't add yet
                            lastHeaderCandidate = line.toUpperCase();
                        }
                        // Check if we're at "Individual Results" - this means the last header candidate is the real header
                        else if (line.match(/^Individual\s+Results/i) && lastHeaderCandidate) {
                            // Add the header now that we know it's real
                            extractedResults.push({
                                isHeader: true,
                                headerText: lastHeaderCandidate,
                                place: '',
                                bib: '',
                                name: '',
                                team: '',
                                time: '',
                                grade: '',
                                points: '',
                                pace: ''
                            });
                            lastHeaderCandidate = null; // Clear it so we don't add it again
                        } else {
                            let result = parseMeetProFormat(line);
                            if (result) {
                                // If we have a header candidate and we're parsing actual results, add the header first
                                if (lastHeaderCandidate) {
                                    extractedResults.push({
                                        isHeader: true,
                                        headerText: lastHeaderCandidate,
                                        place: '',
                                        bib: '',
                                        name: '',
                                        team: '',
                                        time: '',
                                        grade: '',
                                        points: '',
                                        pace: ''
                                    });
                                    lastHeaderCandidate = null;
                                }
                                extractedResults.push(result);
                            }
                        }
                    }
                } else if (hasTiffinPattern) {
                    // Process Tiffin format
                    // Handle multi-line names by merging continuation lines
                    for (let i = 0; i < resultLines.length; i++) {
                        let line = resultLines[i];

                        // Check if next line is a continuation (doesn't start with a number)
                        // and current line starts with a number
                        if (line.match(/^\d+\s/) && i + 1 < resultLines.length &&
                            !resultLines[i + 1].match(/^\d+/) &&
                            resultLines[i + 1].trim().length > 0 &&
                            !resultLines[i + 1].match(/^Page\s|^Race\s|^Place\s/i)) {
                            // Merge the continuation line
                            line = line + ' ' + resultLines[i + 1];
                            i++; // Skip the next line since we merged it
                        }

                        let result = parseTiffinFormat(line);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasRaceDayPattern) {
                    // Process RaceDay Scoring format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRaceDayFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasWebscorerPattern) {
                    // Process Webscorer format (3 lines per runner)
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseWebscorerFormat(resultLines, i);
                        if (result) {
                            extractedResults.push(result);
                            i += (result.linesConsumed - 1); // Skip the lines we just processed
                        }
                    }
                } else if (hasOklahomaPattern) {
                    // Process Oklahoma format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseOklahomaFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasRCCPattern) {
                    // Process RCC Timing format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRCCFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasWebTimerPattern) {
                    // Process Web Timer format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseWebTimerFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasRMSPattern) {
                    // Process Race Management Systems (RMS) format
                    console.log('Processing RMS format');

                    // Look for race headers like "2A Boys" or "Varsity Girls"
                    let lastHeaderCandidate = null;

                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check for race category headers (like "2A Boys")
                        // Pattern: "2A Boys", "Varsity Girls", etc.
                        if (line &&
                            line.match(/^(\d+A|Varsity|JV|Freshman|Sophomore)?\s*(Boys?|Girls?|Men|Women)$/i) &&
                            line.length < 50) {
                            // Store as candidate, add it before first result
                            lastHeaderCandidate = line;
                        } else if (line && line.match(/^Overall Finish List$/i)) {
                            // Overall Finish List can also be a header
                            lastHeaderCandidate = line;
                        } else {
                            let result = parseRMSFormat(line);
                            if (result) {
                                // If we have a header candidate and we're parsing actual results, add the header first
                                if (lastHeaderCandidate) {
                                    extractedResults.push({
                                        isHeader: true,
                                        headerText: lastHeaderCandidate.toUpperCase(),
                                        place: '',
                                        bib: '',
                                        name: '',
                                        team: '',
                                        time: '',
                                        grade: '',
                                        points: '',
                                        pace: ''
                                    });
                                    lastHeaderCandidate = null;
                                }
                                extractedResults.push(result);
                            }
                        }
                    }
                    console.log('RMS parsing complete, extracted', extractedResults.length, 'results');
                } else if (hasVFPPattern) {
                    // Process VFP format
                    // Check if there's a header row to determine column positions
                    let headerColumns = null;
                    let dataStartIndex = 0;

                    // Look for header row in original lines array (may be before startIndex)
                    // Check from startIndex backwards up to 10 lines, then forward in resultLines
                    const headerSearchStart = Math.max(0, startIndex - 10);
                    const headerSearchEnd = Math.min(lines.length, startIndex + 5);

                    for (let i = headerSearchStart; i < headerSearchEnd; i++) {
                        if (lines[i].match(/(O'All\s+Place|Place).*Score.*Bib.*Name.*Team.*Time.*Pace/i)) {
                            // Found header row, parse column positions
                            const headerParts = lines[i].split(/\t/);
                            headerColumns = {};
                            for (let j = 0; j < headerParts.length; j++) {
                                const col = headerParts[j].trim();
                                if (col.match(/Place/i)) headerColumns.place = j;
                                if (col.match(/^Score$/i)) headerColumns.score = j;
                                if (col.match(/Bib/i)) headerColumns.bib = j;
                                if (col.match(/^Name$/i)) headerColumns.name = j;
                                if (col.match(/^Team$/i)) headerColumns.team = j;
                                if (col.match(/^Time$/i)) headerColumns.time = j;
                                if (col.match(/^Pace$/i)) headerColumns.pace = j;
                                if (col.match(/^Year$/i)) headerColumns.year = j;
                            }
                            console.log('VFP header found at line', i, ':', lines[i]);
                            console.log('VFP header columns detected:', headerColumns);
                            break;
                        }
                    }

                    // First, identify team names from the data
                    const knownTeams = identifyVFPTeams(resultLines);

                    for (let i = dataStartIndex; i < resultLines.length; i++) {
                        let result = parseVFPFormat(resultLines[i], knownTeams, headerColumns);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasWyoPrepsPattern) {
                    // Process WyoPreps format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseWyoPrepsFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasRunnercardPattern) {
                    // Process Runnercard format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRunnercardFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasAthleteGuildPattern) {
                    // Process Athlete Guild format
                    // Look for race headers like "Varsity Girls - Overall", "JV Boys - Overall"
                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check for race header pattern
                        // Pattern: "Varsity Girls - Overall", "JV Boys - Overall", "7th Grade Girls - Overall"
                        if (line.match(/^(Varsity|JV|7th Grade|8th Grade)\s+(Boys?|Girls?)\s+-\s+Overall$/i)) {
                            extractedResults.push({
                                isHeader: true,
                                headerText: line.toUpperCase(),
                                place: '',
                                bib: '',
                                name: '',
                                team: '',
                                time: '',
                                grade: '',
                                points: '',
                                pace: ''
                            });
                            continue;
                        }

                        let result = parseAthleteGuildFormat(line);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasEnduranceSplitsPattern) {
                    // Process Endurance Splits format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseEnduranceSplitsFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasSpaceDelimitedPattern) {
                    // Process space-delimited format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseSpaceDelimitedFormat(resultLines[i], i + 1 < resultLines.length ? resultLines[i + 1] : '');
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasRunHighPattern) {
                    // Process RunHigh format
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRunHighFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                } else if (hasKarmaRushPattern) {
                    // Process KarmaRush format
                    let i = 0;
                    while (i < resultLines.length) {
                        // Match place number followed by tab, multiple spaces, or single space + name
                        // This handles both "1\tName" and "1 Name" and "1    Name"
                        if (resultLines[i].match(/^\d+(\t|\s+\w)/)) {
                            let result = parseKarmaRushTabFormat(resultLines, i);
                            if (result) {
                                extractedResults.push(result);
                                i = result.nextIndex;
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                } else if (hasMileSplitPattern) {
                    // Process MileSplit format
                    console.log('Processing MileSplit format');
                    console.log('First 20 resultLines:', resultLines.slice(0, 20));
                    let i = 0;
                    while (i < resultLines.length) {
                        const line = resultLines[i].trim();

                        // Check for event header patterns flanked by "All Events" and "Completed"
                        // Pattern: "All Events" -> event name -> "Completed"
                        if (line.match(/^All Events$/i) && i + 2 < resultLines.length) {
                            const potentialHeader = resultLines[i + 1].trim();
                            const afterHeader = resultLines[i + 2].trim();

                            // If the line after potential header is "Completed", we found a header
                            if (afterHeader.match(/^Completed$/i) && potentialHeader.length > 0) {
                                // Normalize header: convert "5k" to "5km"
                                let normalizedHeader = potentialHeader.replace(/\b5k\b/gi, '5km');
                                extractedResults.push({
                                    isHeader: true,
                                    headerText: normalizedHeader.toUpperCase(),
                                    place: '',
                                    bib: '',
                                    name: '',
                                    team: '',
                                    time: '',
                                    grade: '',
                                    points: '',
                                    pace: ''
                                });
                                i += 3; // Skip "All Events", header, and "Completed"
                                continue;
                            }
                        }

                        // Also check for standalone event header patterns as fallback
                        // Matches formats like: "HS Girls 5k", "Varsity Boys 3200m", "JV Girls 2 Mile", "MS Boys 4k", "Boys 5k Run"
                        if (line.match(/^(HS|MS|Varsity|JV|Freshman|Sophomore|Junior|Senior)\s+(Boys?|Girls?|Men|Women)\s+(\d+k|\d+m|\d*\s*mile)(\s+run)?/i) ||
                            // Also match simpler patterns like "Girls 5k", "Boys 3200m", "Boys 5k Run"
                            line.match(/^(Boys?|Girls?|Men|Women)\s+(\d+k|\d+m|\d*\s*mile)(\s+run)?/i)) {
                            // Normalize header: convert "5k" to "5km"
                            let normalizedHeader = line.replace(/\b5k\b/gi, '5km');
                            extractedResults.push({
                                isHeader: true,
                                headerText: normalizedHeader.toUpperCase(),
                                place: '',
                                bib: '',
                                name: '',
                                team: '',
                                time: '',
                                grade: '',
                                points: '',
                                pace: ''
                            });
                            i++;
                            continue;
                        }

                        if (resultLines[i].match(/^(\d+|--)$/)) {
                            let result = parseMileSplitFormat(resultLines, i);
                            if (result) {
                                extractedResults.push(result);
                                i = result.nextIndex;
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                } else if (hasRunSignupPattern) {
                    // Process RunSignup format
                    let i = 0;
                    while (i < resultLines.length) {
                        // Match place number at start, optionally followed by tab/spaces and bib
                        if (resultLines[i].match(/^\d+(\t|\s+\d{3,4})?(\t|$)/)) {
                            let result = parseRunSignupFormat(resultLines, i);
                            if (result) {
                                extractedResults.push(result);
                                i = result.nextIndex;
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                } else if (hasRaceResultPattern) {
                    // Process RaceResult format
                    // Format: Place, Points, Bib (1-4 digits), Name, Team, Split1, Split2, Split3, Time, Pace
                    console.log('Processing RaceResult format');
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRaceResultFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                    console.log('RaceResult parsing complete, extracted', extractedResults.length, 'results');
                } else if (hasRiverCityPattern) {
                    // Process River City Races format
                    // Format: Place, Name (first last), Team (variable), Bib (3-4 digits), Gender (M/F), Time
                    console.log('Processing River City Races format');
                    for (let i = 0; i < resultLines.length; i++) {
                        let result = parseRiverCityFormat(resultLines[i]);
                        if (result) {
                            extractedResults.push(result);
                        }
                    }
                    console.log('River City parsing complete, extracted', extractedResults.length, 'results');
                } else if (hasHyTekPattern) {
                    // Process HyTek format
                    // Format: Place, Name (Last, First), Grade, Team, Time, Points (optional)
                    // Look for event headers and section headers
                    console.log('Processing HyTek format');
                    let lastHeaderCandidate = null;

                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check for event header (e.g., "Event 2 Boys 5k Run CC")
                        if (line.match(/^Event\s+\d+\s+(Boys?|Girls?|Men|Women)/i)) {
                            // Extract and normalize the event name
                            lastHeaderCandidate = line
                                .replace(/^Event\s+\d+\s+/i, '')
                                .replace(/\s+CC$/i, '')
                                .trim()
                                .toUpperCase();
                        }
                        // Check for results section header (e.g., "Results - Men")
                        else if (line.match(/^Results\s+-\s+(Men|Women)/i)) {
                            // This is a sub-section header, we can skip it
                            continue;
                        }
                        else {
                            let result = parseHyTekFormat(line);
                            if (result) {
                                // If we have a header candidate and we're parsing actual results, add the header first
                                if (lastHeaderCandidate) {
                                    extractedResults.push({
                                        isHeader: true,
                                        headerText: lastHeaderCandidate,
                                        place: '',
                                        bib: '',
                                        name: '',
                                        team: '',
                                        time: '',
                                        grade: '',
                                        points: '',
                                        pace: ''
                                    });
                                    lastHeaderCandidate = null;
                                }
                                extractedResults.push(result);
                            }
                        }
                    }
                    console.log('HyTek parsing complete, extracted', extractedResults.length, 'results');
                } else if (hasAthleticNetPattern) {
                    // Process Athletic.net format
                    // Format: Place, Name (First Last), Grade, Team, Time, Points (optional)
                    // Look for race headers like "Girls 5000 Meter Run Finals"
                    console.log('Processing Athletic.net format');
                    let lastHeaderCandidate = null;
                    let nonScoringCount = 0;

                    for (let i = 0; i < resultLines.length; i++) {
                        const line = resultLines[i].trim();

                        // Check for race header (e.g., "Girls 5000 Meter Run Finals")
                        // Pattern: Gender + Distance + "Meter Run" or "Mile Run" + "Finals"
                        if (line.match(/^(Boys?|Girls?|Men|Women)\s+\d+\s+(Meter|Mile)\s+Run(\s+Finals)?$/i)) {
                            lastHeaderCandidate = line.toUpperCase();
                        }
                        // Skip header row with column names
                        else if (line.match(/^PLACE\s+VIDEO\s+ATHLETE\s+TEAM\s+MARK\s+POINTS/i)) {
                            continue;
                        }
                        else {
                            let result = parseAthleticNetFormat(line);
                            if (result) {
                                // If we have a header candidate and we're parsing actual results, add the header first
                                if (lastHeaderCandidate) {
                                    extractedResults.push({
                                        isHeader: true,
                                        headerText: lastHeaderCandidate,
                                        place: '',
                                        bib: '',
                                        name: '',
                                        team: '',
                                        time: '',
                                        grade: '',
                                        points: '',
                                        pace: ''
                                    });
                                    lastHeaderCandidate = null;
                                }
                                extractedResults.push(result);

                                // Count non-scoring athletes (no points)
                                if (!result.points || result.points === '') {
                                    nonScoringCount++;
                                }
                            }
                        }
                    }
                    console.log('Athletic.net parsing complete, extracted', extractedResults.length, 'results');
                    console.log('Non-scoring athletes (no team points):', nonScoringCount);

                    // Display non-scoring count to user
                    if (nonScoringCount > 0) {
                        document.getElementById('status').textContent =
                            `Extracted ${extractedResults.length} results (${nonScoringCount} non-scoring athletes)`;
                    }
                } else if (hasGoChipPattern) {
                    // Process GoChip format
                    // Multi-line format with place, name, lap times, and bib/chip/team info
                    console.log('Processing GoChip format');
                    let i = 0;
                    while (i < resultLines.length) {
                        const line = resultLines[i].trim();

                        // Skip empty lines and header-like lines
                        if (!line ||
                            line.match(/^(Finish|Name|Lap|Click|FinishName|Categories|Race Tools|Registered|Did Not)/i)) {
                            i++;
                            continue;
                        }

                        // Check if this looks like a place line (number or DNS/DNF)
                        if (line.match(/^\d+$/) || line.match(/^(DNS|DNF|DQ)$/i)) {
                            let result = parseGoChipFormat(resultLines, i);
                            if (result) {
                                extractedResults.push(result);
                                i = result.nextIndex;
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                    console.log('GoChip parsing complete, extracted', extractedResults.length, 'results');
                } else {
                    showError('Could not detect data format. Please ensure you copied the entire results table.');
                    document.getElementById('status').textContent = 'Error';
                    return;
                }

                if (extractedResults.length === 0) {
                    showError('Could not extract any valid results. Please check the format.');
                    document.getElementById('status').textContent = 'Error';
                    return;
                }

                // Check if this is team scores data
                const firstDataRow = extractedResults.find(r => !r.isHeader);
                isTeamScoresMode = firstDataRow && !firstDataRow.bib && !firstDataRow.name && !firstDataRow.grade;

                if (isTeamScoresMode) {
                    displayTeamScores();
                    document.getElementById('outputTabs').style.display = 'flex';
                    switchTab('teamScores');
                } else {
                    displayResults();
                    document.getElementById('outputTabs').style.display = 'none';
                    document.getElementById('resultsContainer').style.display = 'block';
                    document.getElementById('teamScoresContainer').style.display = 'none';
                }

                document.getElementById('rowCount').textContent = extractedResults.length;
                document.getElementById('platform').textContent = detectPlatform(input);
                document.getElementById('status').textContent = 'Complete';

                showToast(`Extracted ${extractedResults.length} results!`);
                
            } catch (error) {
                console.error('Extraction error:', error);
                showError('Error processing input. Please try again.');
                document.getElementById('status').textContent = 'Error';
            }
        }
        
        function parseEnduranceSplitsFormat(line) {
            // Format: "1    1    1164    Sofia Lauren Garza    Mission Sharyland    18:18.8    5:54/M"
            // Columns: O'All Place, Score, Bib No, Name, Team, Time, Pace
            // Skip lines with (< 5) or similar in score column

            // Split by tabs first, then by multiple spaces if no tabs
            let parts;
            if (line.includes('\t')) {
                parts = line.trim().split('\t').map(p => p.trim()).filter(p => p);
            } else {
                // For space-delimited, use a more careful split
                // Match content in parentheses OR sequences of non-space chars
                parts = line.trim().match(/\([^)]*\)|\S+/g);
                if (!parts) return null;
            }

            if (parts.length < 6) return null;

            // First part should be a number (O'All Place)
            if (!parts[0].match(/^\d+$/)) return null;

            let partIndex = 0;

            // O'All Place - use this as the place
            const place = parts[partIndex];
            if (!place.match(/^\d+$/)) return null;
            partIndex++;

            // Score - skip this column entirely
            partIndex++;

            // Bib number
            const bib = parts[partIndex];
            if (!bib.match(/^\d{3,4}$/)) return null;
            partIndex++;

            // Name
            const name = parts[partIndex];
            if (!name || name.length === 0) return null;
            partIndex++;

            // Team
            const team = parts[partIndex];
            if (!team || team.length === 0) return null;
            partIndex++;

            // Time
            const time = parts[partIndex];
            if (!time || !time.match(/\d+:\d+/)) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: '',
                points: '',
                pace: ''
            };
        }

        function identifyVFPTeams(lines) {
            // First pass: identify team names by finding repeated patterns at the end of lines
            const potentialTeams = {};

            for (const line of lines) {
                const trimmed = line.trim();
                const paceMatch = trimmed.match(/\s+(\d{1,2}:\d{2}\/M)\s*$/);
                if (!paceMatch) continue;

                let remaining = trimmed.substring(0, trimmed.length - paceMatch[0].length);
                const timeMatch = remaining.match(/\s+(\d{1,2}:\d{2}\.\d{1,2})\s*$/);
                if (!timeMatch) continue;

                remaining = remaining.substring(0, remaining.length - timeMatch[0].length);
                const gradeMatch = remaining.match(/\s+(\d{1,2}T?)\s*$/);
                if (!gradeMatch) continue;

                remaining = remaining.substring(0, remaining.length - gradeMatch[0].length);

                // Extract everything after the bib number
                const parts = remaining.trim().split(/\s+/);
                if (parts.length < 5) continue; // Need Place Score Bib Name Team

                // Find bib (2-4 digit number after score)
                let bibIndex = -1;
                for (let i = 2; i < Math.min(parts.length, 5); i++) {
                    if (parts[i].match(/^\d{2,4}$/)) {
                        bibIndex = i;
                        break;
                    }
                }
                if (bibIndex === -1) continue;

                const afterBib = parts.slice(bibIndex + 1);
                if (afterBib.length < 3) continue;

                // Try different team name lengths (1-4 words from the end)
                for (let teamLen = 1; teamLen <= Math.min(4, afterBib.length - 2); teamLen++) {
                    const teamName = afterBib.slice(-teamLen).join(' ');
                    potentialTeams[teamName] = (potentialTeams[teamName] || 0) + 1;
                }
            }

            // Return teams that appear 2+ times
            const confirmedTeams = Object.keys(potentialTeams)
                .filter(team => potentialTeams[team] >= 2)
                .sort((a, b) => b.split(' ').length - a.split(' ').length); // Longer names first

            return confirmedTeams;
        }

        function parseVFPFormat(line, knownTeams = [], headerColumns = null) {
            // Format: "Place    Score    Bib No    Name    Team    Grade    Time    Pace"
            // Example: "1    (< 5)    594    Jose Luis Flores    Laredo Harmony School    9    12:08.84    6:04/M"
            // When copied from PDF: "1 (< 5) 594 Jose Luis Flores Laredo Harmony School 9 12:08.84 6:04/M"

            const trimmed = line.trim();

            // If header columns are provided, use direct column indexing
            if (headerColumns) {
                const parts = trimmed.split(/\t/);

                // Validate we have enough parts
                if (parts.length <= Math.max(headerColumns.place || 0, headerColumns.time || 0, headerColumns.pace || 0)) {
                    return null;
                }

                const place = parts[headerColumns.place]?.trim();
                if (!place || !place.match(/^\d+$/)) return null;

                const bib = parts[headerColumns.bib]?.trim();
                if (!bib || !bib.match(/^\d{1,4}$/)) return null;

                const name = parts[headerColumns.name]?.trim();
                if (!name) return null;

                let team = parts[headerColumns.team]?.trim();
                if (!team) return null;

                // Remove any time-like values from team name (split times that got merged)
                // Pattern: MM:SS.S or M:SS.S
                team = team.replace(/\s*\d{1,2}:\d{2}\.\d+/g, '').trim();

                const time = parts[headerColumns.time]?.trim();
                if (!time || !time.match(/^\d{1,2}:\d{2}\.\d{1,2}$/)) return null;

                const pace = parts[headerColumns.pace]?.trim();
                const grade = headerColumns.year !== undefined ? parts[headerColumns.year]?.trim() : '';

                return {
                    place: place,
                    bib: bib,
                    name: name,
                    team: team,
                    time: time,
                    grade: grade || '',
                    points: '',
                    pace: pace || ''
                };
            }

            // Extract from right to left (more reliable):
            // Two possible formats:
            // 1. Original: Place Score Bib Name Team [Grade] Time Pace
            // 2. With splits: Place Score Bib Name Team 1M 2M 5K Time Pace [Year]

            // Check if there's a year/grade at the very end (after pace)
            let grade = '';
            let workingStr = trimmed;
            const yearAtEndMatch = workingStr.match(/\s+(\d{1,2}T?)\s*$/);
            if (yearAtEndMatch && yearAtEndMatch[1].match(/^\d{1,2}T?$/)) {
                // Could be a year/grade at the end
                const potentialYear = yearAtEndMatch[1];
                // Check if there's a pace pattern before it
                const beforeYear = workingStr.substring(0, workingStr.length - yearAtEndMatch[0].length);
                if (beforeYear.match(/\d{1,2}:\d{2}\/M\s*$/)) {
                    // Yes, this is the year after pace
                    grade = potentialYear.replace(/T$/i, '');
                    workingStr = beforeYear;
                }
            }

            // Pace: "6:04/M" or "5:27/M" or "4:42/M"
            const paceMatch = workingStr.match(/\s+(\d{1,2}:\d{2}\/M)\s*$/);
            if (!paceMatch) return null;
            let remaining = workingStr.substring(0, workingStr.length - paceMatch[0].length);

            // Time before pace: "12:08.84" or "16:55.0" or "14:40.0" (1 or 2 decimal places)
            // This should be the LAST time value before pace (not split times)
            const timeMatch = remaining.match(/\s+(\d{1,2}:\d{2}\.\d{1,2})\s*$/);
            if (!timeMatch) return null;
            const time = timeMatch[1];
            remaining = remaining.substring(0, remaining.length - timeMatch[0].length);

            // Remove any split times before the final time (e.g., "4:44.4 9:35.2 14:40.0")
            // Split times are also in MM:SS.S format, so remove them
            while (remaining.match(/\s+\d{1,2}:\d{2}\.\d{1,2}\s*$/)) {
                remaining = remaining.replace(/\s+\d{1,2}:\d{2}\.\d{1,2}\s*$/, '');
            }

            // Grade before splits/time (original format): "9", "10", "11", "12", or "9T"
            // Only check if we haven't already found grade at the end
            if (!grade) {
                const gradeMatch = remaining.match(/\s+(\d{1,2}T?)\s*$/);
                if (gradeMatch) {
                    grade = gradeMatch[1].replace(/T$/i, '');
                    remaining = remaining.substring(0, remaining.length - gradeMatch[0].length);
                }
            }

            // Now from left: Place, Score, Bib, Name, Team
            // Could be: "1 1 35 Lionel Vargas MARTIN" or "1 (< 5) 594 Jose Luis Flores Laredo"
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 4) return null;

            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Find the bib number - it's a 2-4 digit number that comes after score
            // Score could be a number or (< 5) or (> 7) or (<, 5) or (>, 7)
            let bibIndex = -1;

            if (parts[1].match(/^\(/) || parts[1] === '(<' || parts[1] === '(>') {
                // Score is "(< 5)" or "(> 7)" which might be split as "(<", "5)" or "(>", "7)" or as single token
                if (parts[1] === '(<' || parts[1] === '(>') {
                    // Split as "(<" "5)" or "(>" "7)" - bib is at index 3
                    bibIndex = 3;
                } else {
                    // "(< 5)" or "(> 7)" as single token - bib is at index 2
                    bibIndex = 2;
                }
            } else if (parts[1].match(/^\d+$/)) {
                // Score is a number - bib is at index 2
                bibIndex = 2;
            } else {
                return null; // Invalid score format
            }

            if (bibIndex >= parts.length) return null;
            const bib = parts[bibIndex];
            // Bib can be 1-4 digits (1, 35, 594, etc.)
            if (!bib.match(/^\d{1,4}$/)) return null;

            // Everything between bib and grade is Name + Team
            const nameTeamParts = parts.slice(bibIndex + 1);
            if (nameTeamParts.length < 3) return null; // Need at least First Last Team

            let name, team;

            // If we have known teams, try to match from the end
            if (knownTeams && knownTeams.length > 0) {
                const nameTeamStr = nameTeamParts.join(' ');
                let matched = false;

                // Try to match known teams (longest first)
                for (const knownTeam of knownTeams) {
                    if (nameTeamStr.endsWith(knownTeam)) {
                        team = knownTeam;
                        name = nameTeamStr.substring(0, nameTeamStr.length - knownTeam.length).trim();
                        matched = true;
                        break;
                    }
                }

                if (!matched) {
                    // Fallback to 2-word name
                    name = nameTeamParts.slice(0, 2).join(' ');
                    team = nameTeamParts.slice(2).join(' ');
                }
            } else {
                // No known teams, use simple heuristic: First 2 words are name
                name = nameTeamParts.slice(0, 2).join(' ');
                team = nameTeamParts.slice(2).join(' ');
            }

            if (!team || team.length === 0 || !name || name.length === 0) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: ''
            };
        }

        function parseWyoPrepsFormat(line) {
            // Format: "Place    Bib    Name    Year    Team Name    Score    Team Score    Team Place    Clock Time    Pace"
            // Example: "1    3677    Raina Wachob    10    Cody High School    1    19    1    20:59.7    6:46"
            // Example: "7    3670    Danielle Foote    10    Cody High School    (7)    19    1    22:32.0    7:16"
            // Example: "13    3675    Sunday Schuh    12    Cody High School    > 7    19    1    22:58.6    7:25"
            // Pattern: Tab or multi-space separated
            // Score can be: number, (number), or "> 7"

            const trimmed = line.trim();

            // Parse from right to left (more reliable)
            // Pace at end: "6:46" (M:SS format without /M)
            const paceMatch = trimmed.match(/\s+(\d{1,2}:\d{2})\s*$/);
            if (!paceMatch) return null;
            const pace = paceMatch[1];
            let remaining = trimmed.substring(0, trimmed.length - paceMatch[0].length);

            // Clock Time before pace: "20:59.7" (MM:SS.S format)
            const timeMatch = remaining.match(/\s+(\d{1,2}:\d{2}\.\d)\s*$/);
            if (!timeMatch) return null;
            const time = timeMatch[1];
            remaining = remaining.substring(0, remaining.length - timeMatch[0].length);

            // Team Place before time: "1" (1 or 2 digits)
            const teamPlaceMatch = remaining.match(/\s+(\d{1,2})\s*$/);
            if (!teamPlaceMatch) return null;
            remaining = remaining.substring(0, remaining.length - teamPlaceMatch[0].length);

            // Team Score before Team Place: "19" (1-3 digits) or "Incomplete"
            const teamScoreMatch = remaining.match(/\s+(Incomplete|\d{1,3})\s*$/);
            if (!teamScoreMatch) return null;
            remaining = remaining.substring(0, remaining.length - teamScoreMatch[0].length);

            // Score before Team Score: can be number, (number), "> 7", "< 5", or "< 5" (with space)
            // Match any of these patterns
            const scoreMatch = remaining.match(/\s+(<|>)\s*(\d+|\(\d+\))\s*$/) || remaining.match(/\s+(\d+|\(\d+\))\s*$/);
            if (!scoreMatch) return null;
            remaining = remaining.substring(0, remaining.length - scoreMatch[0].length);

            // Now from left: Place, Bib, Name (2 words), Year, Team (multi-word)
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 6) return null; // Need Place, Bib, FirstName, LastName, Year, Team (at least 1 word)

            // Place
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Bib (4 digits, but could be 3 in some cases)
            const bib = parts[1];
            if (!bib.match(/^\d{3,5}$/)) return null;

            // Name (2 words: First Last)
            const firstName = parts[2];
            const lastName = parts[3];
            const name = `${firstName} ${lastName}`;

            // Year/Grade
            const year = parts[4];
            if (!year.match(/^(7|8|9|10|11|12)$/)) return null;

            // Team (everything remaining - could be multi-word)
            const team = parts.slice(5).join(' ');
            if (!team || team.length === 0) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: year,
                points: '',
                pace: pace
            };
        }

        function parseRunnercardFormat(line) {
            // Format: "Place.    Bib    Name    Year    Team    Time    Score"
            // Example: "1.    58    River Shaw    Jr    1.    Grand County HS    16:52.9    1"
            // Example: "27.    93    Noah Begay    Sr    8.    San Juan HS    18:58.8        " (no score - non-scoring)
            // Pattern: Tab or multi-space separated
            // Place ends with period, Team starts with team place number followed by period

            const trimmed = line.trim();

            // Parse from right to left for reliability
            // Score at end (optional - may be blank for non-scoring runners)
            let score = '';
            let remaining = trimmed;

            // Check if line ends with a score (1-2 digit number or blank spaces)
            const scoreMatch = trimmed.match(/\s+(\d{1,2})\s*$/);
            if (scoreMatch) {
                score = scoreMatch[1];
                remaining = trimmed.substring(0, trimmed.length - scoreMatch[0].length);
            }

            // Time before score: "16:52.9" (MM:SS.S format)
            const timeMatch = remaining.match(/\s+(\d{1,2}:\d{2}\.\d)\s*$/);
            if (!timeMatch) return null;
            const time = timeMatch[1];
            remaining = remaining.substring(0, remaining.length - timeMatch[0].length);

            // Team before time: starts with team place number and period "1.    Grand County HS"
            // Match: number, period, then team name (multi-word)
            const teamMatch = remaining.match(/\s+(\d+)\.\s+([\w\s]+?)\s*$/);
            if (!teamMatch) return null;
            const team = teamMatch[2].trim();
            remaining = remaining.substring(0, remaining.length - teamMatch[0].length);

            // Year/Grade before team: "Fr", "So", "Jr", "Sr"
            const yearMatch = remaining.match(/\s+(Fr|So|Jr|Sr)\s*$/i);
            if (!yearMatch) return null;
            const year = yearMatch[1];
            remaining = remaining.substring(0, remaining.length - yearMatch[0].length);

            // Now from left: Place (with period), Bib, Name (2 words)
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 4) return null; // Need Place., Bib, FirstName, LastName

            // Place (ends with period)
            const placeStr = parts[0];
            if (!placeStr.match(/^\d+\.$/)) return null;
            const place = placeStr.replace('.', '');

            // Bib (1-4 digits)
            const bib = parts[1];
            if (!bib.match(/^\d{1,4}$/)) return null;

            // Name (remaining words before year)
            const name = parts.slice(2).join(' ');
            if (!name || name.length === 0) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: year,
                points: score,
                pace: ''
            };
        }

        function parseRCCFormat(line) {
            // Format: "Overall Score Bib# Name Class Chip Time Team"
            // Example: "1 1 353 Noah Bontrager SR 00:15:21.54 Westview"
            // Example: "21 21 365 Nathan Troxel Gonzalez JR 00:18:08.34 West Noble"
            // Middle School: "1 1 4788 Emmett Glenn 8th 00:10:11.64 Bellmont"
            // Middle School (no class): "21 20 2519 Jacob Chacon 00:11:34.55 New Haven"
            // Score can be: number, 0, or (number) for non-scoring

            const trimmed = line.trim();

            // Work from right to left
            // First find Class and Time pattern
            // Class can be: SR, JR, SO, FR (high school) or 6th/7th/8th or 6/7/8 (middle school) or missing
            let classTimeMatch = trimmed.match(/\s+(SR|JR|SO|FR|[678]th?|1[0-2]th?)\s+(\d{2}:\d{2}:\d{2}\.\d+)\s+(.+?)\s*$/i);

            let classField = '';
            let time = '';
            let team = '';
            let remaining = '';

            if (classTimeMatch) {
                // Has class field
                classField = classTimeMatch[1];
                time = classTimeMatch[2];
                team = classTimeMatch[3];
                remaining = trimmed.substring(0, trimmed.length - classTimeMatch[0].length);
            } else {
                // No class field - try just time and team
                const timeTeamMatch = trimmed.match(/\s+(\d{2}:\d{2}:\d{2}\.\d+)\s+(.+?)\s*$/);
                if (!timeTeamMatch) return null;

                time = timeTeamMatch[1];
                team = timeTeamMatch[2];
                remaining = trimmed.substring(0, trimmed.length - timeTeamMatch[0].length);
            }

            // Remove leading "00:" from time
            if (time.startsWith('00:')) {
                time = time.substring(3);
            }

            // Now parse from left: Overall, Score, Bib#, Name
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 3) return null;

            // Overall
            const overall = parts[0];
            if (!overall.match(/^\d+$/)) return null;

            // Score (skip it - can be number, 0, or (number))
            let partIndex = 1;
            if (parts[1].match(/^\(?\d+\)?$/)) {
                partIndex = 2; // Skip score
            }

            // Bib#
            const bib = parts[partIndex];
            if (!bib.match(/^\d{2,5}$/)) return null;
            partIndex++;

            // Name (everything remaining)
            const name = parts.slice(partIndex).join(' ');
            if (!name || name.length === 0) return null;

            // Remove "th" suffix from grade (8th -> 8, 7th -> 7, etc.)
            let grade = classField;
            if (grade && grade.match(/^\d+th$/i)) {
                grade = grade.replace(/th$/i, '');
            }

            return {
                place: overall,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: ''
            };
        }

        function parseOklahomaFormat(line) {
            // Format: Place, Bib, Name, Grade, Team, Score, Time, Pace
            // Example: "1 99 Tatum Penland 10 Bixby High School 1 00:19:15 6:12"
            // Example: "21 119 Maggie Kershen 10 Norman High School (21) 00:21:37 6:58"
            // Score can be: number or (number) for non-scoring

            const trimmed = line.trim();

            // Parse from right to left
            // Pace at end: "6:12" or "5:27"
            const paceMatch = trimmed.match(/\s+(\d{1,2}:\d{2})\s*$/);
            if (!paceMatch) return null;
            const pace = paceMatch[1];
            let remaining = trimmed.substring(0, trimmed.length - paceMatch[0].length);

            // Time before pace: "00:19:15" or "19:15"
            const timeMatch = remaining.match(/\s+(\d{2}:\d{2}:?\d{0,2})\s*$/);
            if (!timeMatch) return null;
            let time = timeMatch[1];
            remaining = remaining.substring(0, remaining.length - timeMatch[0].length);

            // Remove leading "00:" from time
            if (time.startsWith('00:')) {
                time = time.substring(3);
            }

            // Score before time: number or (number)
            const scoreMatch = remaining.match(/\s+(\(?\d+\)?)\s*$/);
            if (!scoreMatch) return null;
            remaining = remaining.substring(0, remaining.length - scoreMatch[0].length);

            // Now parse from left: Place, Bib, Name (first last), Grade, Team
            const parts = remaining.trim().split(/\s+/);
            if (parts.length < 5) return null;

            // Place
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Bib
            const bib = parts[1];
            if (!bib.match(/^\d{1,5}$/)) return null;

            // Name (first last) - 2 words
            const name = parts[2] + ' ' + parts[3];

            // Grade (9, 10, 11, 12)
            const grade = parts[4];
            if (!grade.match(/^(9|10|11|12)$/)) return null;

            // Team (everything remaining)
            const team = parts.slice(5).join(' ');
            if (!team || team.length === 0) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: pace
            };
        }

        function parseWebscorerFormat(lines, index) {
            // Format: Place, Bib, Name on one line, Team-Grade on next line, Category, Gender, Time, Difference
            // Line 1: "1    7072    Boyd Hamby"
            // Line 2: "Mcloud - 12"
            // Line 3: "High School Boys    M    16:49.62    -"

            if (index + 2 >= lines.length) return null;

            const line1 = lines[index].trim();
            const line2 = lines[index + 1].trim();
            const line3 = lines[index + 2].trim();

            // Parse line 1: Place, Bib, Name (tab or multi-space separated)
            const parts1 = line1.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);
            if (parts1.length < 3) return null;

            const place = parts1[0];
            if (!place.match(/^\d+$/)) return null;

            const bib = parts1[1];
            if (!bib.match(/^\d{1,5}$/)) return null;

            const name = parts1[2];
            if (!name || name.length === 0) return null;

            // Parse line 2: Team - Grade
            // Example: "Mcloud - 12" or "Prague - 11"
            const teamGradeMatch = line2.match(/^(.+?)\s*-\s*(\d{1,2})\s*$/);
            if (!teamGradeMatch) return null;

            const team = teamGradeMatch[1].trim();
            const grade = teamGradeMatch[2];

            // Parse line 3: Category, Gender, Time, Difference
            const parts3 = line3.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);
            if (parts3.length < 2) return null;

            // Time format: MM:SS.XX
            let time = null;
            for (let i = 0; i < parts3.length; i++) {
                if (parts3[i].match(/^\d{1,2}:\d{2}\.\d{2}$/)) {
                    time = parts3[i];
                    break;
                }
            }
            if (!time) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: '',
                linesConsumed: 3 // This parser consumes 3 lines
            };
        }

        function parseRaceDayFormat(line) {
            // Format: Place, Bib, Name, Year, Team Name, Score, Team Score, Team Place, Clock Time, Pace
            // Example: "1    211    Teagan Kennedy        Maumee    1    36    1    00:18:03.10    5:49"
            // Score can be: number, (number), or "> 7"

            const trimmed = line.trim();

            // Split by tabs or multiple spaces
            const parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            if (parts.length < 8) return null;

            // Place - first column
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Bib - second column
            const bib = parts[1];
            if (!bib.match(/^\d{1,5}$/)) return null;

            // Name - third column
            const name = parts[2];
            if (!name || name.length === 0) return null;

            // Year - fourth column (often empty, skip it)
            let partIndex = 3;
            // If the next part looks like a year (9-12) or is empty, skip it
            if (parts[partIndex].match(/^(9|10|11|12)?$/)) {
                partIndex = 4;
            }

            // Team Name - should be at partIndex now
            const team = parts[partIndex];
            if (!team || team.length === 0) return null;
            partIndex++;

            // Score - can be number, (number), "> 7", or "Incomplete"
            // Skip this column
            partIndex++;

            // Team Score - skip
            partIndex++;

            // Team Place - skip
            partIndex++;

            // Clock Time
            let time = parts[partIndex];
            if (!time || !time.match(/\d{2}:\d{2}:\d{2}\.\d{2}/)) return null;

            // Remove leading "00:" from time
            if (time.startsWith('00:')) {
                time = time.substring(3);
            }

            // Pace (optional)
            const pace = parts.length > partIndex + 1 ? parts[partIndex + 1] : '';

            // Extract grade from Year column if it was there
            const grade = parts[3].match(/^(9|10|11|12)$/) ? parts[3] : '';

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: pace
            };
        }

        function parseMeetProFormat(line) {
            // Format: Place, Name (LAST, First), Yr., #, Team, Score, Time, Gap, Avg. Mile, Avg. kM
            // Example: "1    ESEVERRI, Diego    SR    568    Columbus    1    15:30.6    ---    4:59.2"
            // Example: "2    GARGANO, Massimo    SR    567    Columbus    2    15:46.1    15.5    5:04.2"
            // Example: "1    MYERS, Colton    8    3006    Trinity    1    11:35.5    ---    5:47/M"
            // Example with no grade: "2    LEFKO, Noah        3275    WIND Runners    1    10:15.7    16.7    5:31.0"
            // Example with no gap: "1    FERNLUND, Philip    FR    1568    Oviedo    1    18:50.0    6:03.3"
            // Example with single spaces: "25 MARTINEZ, Alek FR 1333 Hialeah Educational - 22:23.5 3:58.6 7:12.0 4:28.7"
            // Example with parentheses in score: "37 BRYCE, Ian 7 406 Calvary Christian (F (27) 23:17.8 4:52.9 7:29.5 4:39.6"

            const trimmed = line.trim();

            // Skip non-data lines
            if (!trimmed || trimmed.match(/^(Place|Athlete|Individual|Team|---+|\d+\)|Yr\.|#|Score|Time|Gap|Avg)/i)) {
                return null;
            }

            // Try splitting by tabs or multiple spaces first
            let parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            // If we only got 1-2 parts, this is likely single-space delimited
            // Parse it differently by working from both ends
            if (parts.length < 6) {
                parts = trimmed.split(/\s+/);

                if (parts.length < 6) return null;

                // Parse from left: Place, Name (LAST, First), [Grade], Bib
                const place = parts[0];
                if (!place.match(/^\d+$/)) return null;

                // Find the name (LAST, First format)
                let nameEndIndex = -1;
                for (let i = 1; i < parts.length - 4; i++) {
                    if (parts[i].includes(',')) {
                        // Check if next part looks like the rest of the name or a grade/bib
                        if (i + 1 < parts.length && !parts[i + 1].match(/^(FR|SO|JR|SR|[6-8]|\d{3,})$/i)) {
                            // Multi-word name, combine this and next part
                            nameEndIndex = i + 1;
                        } else {
                            nameEndIndex = i;
                        }
                        break;
                    }
                }

                if (nameEndIndex === -1) return null;

                const name = parts.slice(1, nameEndIndex + 1).join(' ');
                if (!name.includes(',')) return null;

                // Next is either grade or bib
                let currentIndex = nameEndIndex + 1;
                let grade = '';

                if (currentIndex < parts.length && parts[currentIndex].match(/^(FR|SO|JR|SR|[6-8])$/i)) {
                    grade = parts[currentIndex].toUpperCase();
                    currentIndex++;
                }

                // Bib number
                if (currentIndex >= parts.length) return null;
                const bib = parts[currentIndex];
                if (!bib.match(/^\d+$/)) return null;
                currentIndex++;

                // Now find the time field - it's the FIRST time-like value after currentIndex
                // Format: Team... Score Time Gap [Avg.Mile] [Avg.kM]
                // Time is always in MM:SS.S format, typically longer (e.g., 22:23.5)
                // Gap and pace fields are also time-like but typically shorter
                let timeIndex = -1;
                for (let i = currentIndex; i < parts.length; i++) {
                    if (parts[i].match(/^\d{1,2}:\d{2}\.\d/)) {
                        timeIndex = i;
                        break;
                    }
                }

                if (timeIndex === -1) return null;
                const time = parts[timeIndex];

                // Score is right before time (can be number, "-", or "(number)")
                if (timeIndex - 1 < currentIndex) return null;
                let scoreIndex = timeIndex - 1;
                let score = parts[scoreIndex];

                // Handle scores in parentheses like "(27)"
                if (score.match(/^\(\d+\)$/)) {
                    score = score.replace(/[()]/g, '');
                } else if (score === '-') {
                    score = '';
                }

                // Team is everything between bib and score
                if (scoreIndex <= currentIndex) return null;
                const team = parts.slice(currentIndex, scoreIndex).join(' ');

                if (!team || team.length === 0) return null;

                return {
                    place: place,
                    bib: bib,
                    name: name,
                    team: team,
                    time: time,
                    grade: grade,
                    points: score.match(/^\d+$/) ? score : '',
                    pace: ''
                };
            }

            // Original tab/multi-space delimited parsing
            // Need at least: Place, Name, Bib, Team, Score, Time (6 fields minimum if no grade/gap/pace)
            // Could have up to 9 fields: Place, Name, Grade, Bib, Team, Score, Time, Gap, Pace
            if (parts.length < 6) return null;

            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Name is in format "LAST, First" or "LAST, First Middle"
            const name = parts[1];
            if (!name || !name.includes(',')) return null;

            // Check if parts[2] is a grade (FR, SO, JR, SR, or 6-8) or a bib number
            let grade = '';
            let bibIndex = 2;

            if (parts[2] && parts[2].match(/^(FR|SO|JR|SR|[6-8])$/i)) {
                // Grade is present
                grade = parts[2].toUpperCase();
                bibIndex = 3;
            }
            // else: No grade, bibIndex stays at 2

            // Bib number
            const bib = parts[bibIndex];
            if (!bib || !bib.match(/^\d+$/)) return null;

            // Team name
            const team = parts[bibIndex + 1];
            if (!team || team.length === 0) return null;

            // Score (can be a number or "--" or other markers)
            const score = parts[bibIndex + 2];

            // Time (MM:SS.S format)
            const time = parts[bibIndex + 3];
            if (!time || !time.match(/^\d{1,2}:\d{2}\.\d/)) return null;

            // Gap is parts[bibIndex + 4] - we ignore it
            // Avg. Mile/Pace is parts[bibIndex + 5] - optional

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: score && score.match(/^\d+$/) ? score : '',
                pace: ''
            };
        }

        function parseTiffinFormat(line) {
            // Format: Place Name Grade Team Time Points
            // Example: "1 Andrew Seiverth 12 Perrysburg 17:35.4 1"
            // Example: "23 Christian Rodriguez 9 Perrysburg 18:44.5"
            // Note: Columns can be separated by single OR multiple spaces/tabs

            const trimmed = line.trim();

            // Try splitting by tabs or 2+ spaces first
            let parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            // If we got exactly 1 part, the line is likely space-separated
            // Parse from right-to-left since we know Time and Grade positions
            if (parts.length === 1 || parts.length < 5) {
                parts = trimmed.split(/\s+/);

                if (parts.length < 5) return null;

                // Parse from left and right
                const place = parts[0];
                if (!place.match(/^\d+$/)) return null;

                // Points (optional) - last column if it's a number AND there are enough parts
                let points = '';
                let endIndex = parts.length;

                // Check if last element is points (single/double digit number)
                if (parts.length >= 6 && parts[parts.length - 1].match(/^\d{1,2}$/)) {
                    // Make sure the second-to-last is the time
                    if (parts[parts.length - 2].match(/^\d{1,2}:\d{2}\.\d$/)) {
                        points = parts[parts.length - 1];
                        endIndex--;
                    }
                }

                // Time - before points (MM:SS.S format)
                const time = parts[endIndex - 1];
                if (!time || !time.match(/^\d{1,2}:\d{2}\.\d$/)) return null;
                endIndex--;

                // Find grade by scanning backwards from time
                // Grade is the first number (7-12) we find before the time
                let gradeIndex = -1;
                for (let i = endIndex - 1; i >= 1; i--) {
                    if (parts[i].match(/^(7|8|9|10|11|12)$/)) {
                        gradeIndex = i;
                        break;
                    }
                }
                if (gradeIndex === -1) return null;

                const grade = parts[gradeIndex];

                // Team - everything between grade and time
                const team = parts.slice(gradeIndex + 1, endIndex).join(' ');
                if (!team || team.length === 0) return null;

                // Name - everything between place and grade
                const name = parts.slice(1, gradeIndex).join(' ');
                if (!name || name.length === 0) return null;

                return {
                    place: place,
                    bib: '',
                    name: name,
                    team: team,
                    time: time,
                    grade: grade,
                    points: points,
                    pace: ''
                };
            }

            // Tab or multi-space separated
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            const name = parts[1];
            if (!name || name.length === 0) return null;

            const grade = parts[2];
            if (!grade.match(/^(7|8|9|10|11|12)$/)) return null;

            const team = parts[3];
            if (!team || team.length === 0) return null;

            const time = parts[4];
            if (!time || !time.match(/^\d{1,2}:\d{2}\.\d$/)) return null;

            const points = parts.length > 5 ? parts[5] : '';

            return {
                place: place,
                bib: '',
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: points,
                pace: ''
            };
        }

        function parseWebTimerFormat(line) {
            // Format from web timing systems with many columns
            // Example 1: "1    889    Hailyn Counts    00:12:45.9    All Ages    1    Female    1    Austin Brentwood Christian Acade    5    1..."
            // Columns: Pos, Race No, Name, Time, Division, Division Pos, Gender, Gen Pos, Team, Team Pos...
            // Example 2: "1    768    Marcus Benjamin    00:16:10.2    Varsity Boys    1    Male    Weyauwega-Fremont    1    5:12 min/m"
            // Columns: Pos, Race No, Name, Time, Age Group, Team Points, Gender, Team, Pos In Team, Pace

            // Split by tabs or multiple spaces
            const parts = line.trim().split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            if (parts.length < 8) return null;

            // Position (place) - first column
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Race No (bib) - second column
            const bib = parts[1];
            if (!bib.match(/^\d{1,5}$/)) return null;

            // Name - third column
            const name = parts[2];
            if (!name || name.length === 0) return null;

            // Time - fourth column (format: 00:12:45.9 or "Not started")
            let time = parts[3];
            if (!time || time === 'Not') return null; // Skip "Not started" entries
            if (!time.match(/\d{2}:\d{2}:\d{2}\.\d/)) return null;

            // Remove leading "00:" from time (convert 00:12:45.9 to 12:45.9)
            if (time.startsWith('00:')) {
                time = time.substring(3);
            }

            // Team - varies by format and whether Team Points is filled
            // Performance Timing with Team Points: Pos, Race No, Name, Time, Age Group, Team Points, Gender, Team, Pos In Team, Pace
            //   After split: [0-Pos, 1-RaceNo, 2-Name, 3-Time, 4-AgeGroup, 5-TeamPts, 6-Gender, 7-Team, 8-PosInTeam, 9-Pace]
            // Performance Timing without Team Points: Pos, Race No, Name, Time, Age Group, Gender, Team, Pos In Team, Pace
            //   After split: [0-Pos, 1-RaceNo, 2-Name, 3-Time, 4-AgeGroup, 5-Gender, 6-Team, 7-PosInTeam, 8-Pace]
            // Other Web Timer: Pos, Race No, Name, Time, Division, Division Pos, Gender, Gen Pos, Team, Team Pos
            //   After split: [0-Pos, 1-RaceNo, 2-Name, 3-Time, 4-Div, 5-DivPos, 6-Gender, 7-GenPos, 8-Team, 9-TeamPos]

            let team = null;

            // Find Gender column first
            let genderIndex = -1;
            for (let i = 5; i < Math.min(parts.length, 8); i++) {
                if (parts[i] === 'Male' || parts[i] === 'Female') {
                    genderIndex = i;
                    break;
                }
            }

            if (genderIndex === -1) return null;

            // Team is 1 or 2 positions after Gender
            if (genderIndex === 5) {
                // Performance Timing without Team Points: Gender at 5, Team at 6
                team = parts[6];
            } else if (genderIndex === 6) {
                // Performance Timing with Team Points: Gender at 6, Team at 7
                team = parts[7];
            } else if (genderIndex === 7) {
                // Other Web Timer: Gender at 7, skip Gen Pos, Team at 8
                team = parts.length > 8 ? parts[8] : null;
            }

            // Validate team is not a single/double digit number (which would be Pos In Team)
            if (!team || team.length === 0 || team.match(/^\d{1,2}$/)) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: '',
                points: '',
                pace: ''
            };
        }

        function parseCompetitiveTimingFormat(line) {
            // Format: Place, Bib, Name, Year, Team Name, Score, Team Score, Team Place, Clock Time, Pace
            // Example: "1    4244    Karee Cooley    11    Powell High School    1    41    2    18:34.88    6:00"
            // Score can be: number, "(number)" for non-scoring, "< 5", "> 7"

            const trimmed = line.trim();

            // Skip header lines and non-data lines
            if (!trimmed ||
                trimmed.match(/^(Place|Bib|Name|Year|Team|Score|Clock|Time|Pace|Top)/i) ||
                trimmed.match(/^-+$/)) {
                return null;
            }

            // Split by tabs or multiple spaces
            const parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            if (parts.length < 10) return null;

            // Place - first column
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Bib - second column
            const bib = parts[1];
            if (!bib.match(/^\d{3,5}$/)) return null;

            // Name - third column (format: "FirstName LastName")
            const name = parts[2];
            if (!name || name.length === 0) return null;

            // Year/Grade - fourth column (9-12)
            const grade = parts[3];
            if (!grade.match(/^\d{1,2}$/)) return null;

            // Team Name - fifth column
            const team = parts[4];
            if (!team || team.length === 0) return null;

            // Score - sixth column (can be number, "(number)", "< 5", "> 7")
            const score = parts[5];

            // Skip Team Score (seventh column) and Team Place (eighth column)

            // Clock Time - ninth column (format: MM:SS.SS)
            const time = parts[8];
            if (!time || !time.match(/^\d{1,2}:\d{2}\.\d{2}$/)) return null;

            // Pace - tenth column (format: M:SS)
            const pace = parts[9];
            if (!pace || !pace.match(/^\d{1,2}:\d{2}$/)) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: score && score.match(/^\d+$/) ? score : '',
                pace: pace
            };
        }

        function parseRaceRosterFormat(line) {
            // Format: Bib, Name, Overall Place, Team Name, Class, Team Place, Scoring Place, Pace, Time, [optional split fields]
            // Example: "537    Banner Barnes    1    NOBLESVILLE    JR    1    1    4:52    15:03.7    07:35.0    4:54    2    07:28.7    4:50    1"
            // Example with no team place: "538    Cohen Baumer    46    NOBLESVILLE    FR    9        5:27    16:51.8    08:21.2    5:24    53    08:30.7    5:30    40"

            const trimmed = line.trim();

            // Skip header lines and non-data lines
            if (!trimmed ||
                trimmed.match(/^(Bib|Name|Overall|Team|Class|Place|Scoring|Pace|Time|First|Second|Half|Filters|Search)/i) ||
                trimmed.match(/^-+$/)) {
                return null;
            }

            // Split by tabs or multiple spaces
            const parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            if (parts.length < 7) return null; // At minimum: Bib, Name, Place, Team, Grade, Pace, Time

            // Bib - first column
            const bib = parts[0];
            if (!bib.match(/^\d{1,4}$/)) return null;

            // Name - second column (format: "FirstName LastName")
            const name = parts[1];
            if (!name || name.length === 0) return null;

            // Overall Place - third column
            const place = parts[2];
            if (!place.match(/^\d+$/)) return null;

            // Team Name - fourth column
            const team = parts[3];
            if (!team || team.length === 0) return null;

            // Class - fifth column (FR, SO, JR, SR)
            const grade = parts[4];
            if (!grade.match(/^(FR|SO|JR|SR)$/i)) return null;

            // Now we need to find Pace and Time by scanning from the end
            // Time is always last (MM:SS.S format)
            const time = parts[parts.length - 1];
            if (!time || !time.match(/^\d{1,2}:\d{2}\.\d$/)) return null;

            // Pace is second to last (M:SS format)
            const pace = parts[parts.length - 2];
            if (!pace || !pace.match(/^\d{1,2}:\d{2}$/)) return null;

            // Scoring Place is the field before Pace (if it exists and is a number)
            let scoringPlace = '';
            if (parts.length >= 8) {
                const possibleScoringPlace = parts[parts.length - 3];
                if (possibleScoringPlace && possibleScoringPlace.match(/^\d+$/)) {
                    scoringPlace = possibleScoringPlace;
                }
            }

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade.toUpperCase(),
                points: scoringPlace,
                pace: pace
            };
        }

        function calculateRaceDistance(pace, time) {
            // Parse pace (M:SS per mile or per km)
            const paceMatch = pace.match(/^(\d{1,2}):(\d{2})$/);
            if (!paceMatch) {
                return null;
            }
            const paceMinutes = parseInt(paceMatch[1]);
            const paceSeconds = parseInt(paceMatch[2]);
            const paceInSeconds = paceMinutes * 60 + paceSeconds;

            // Parse time (MM:SS)
            const timeMatch = time.match(/^(\d{1,2}):(\d{2})$/);
            if (!timeMatch) {
                return null;
            }
            const timeMinutes = parseInt(timeMatch[1]);
            const timeSeconds = parseInt(timeMatch[2]);
            const timeInSeconds = timeMinutes * 60 + timeSeconds;

            // Calculate distance in miles
            const distanceInMiles = timeInSeconds / paceInSeconds;

            // Check if it's close to 5K (3.10686 miles)
            const fiveKMiles = 3.10686;
            const threeMiles = 3.0;

            // Allow 3% tolerance for better matching
            const tolerance = 0.03;

            if (Math.abs(distanceInMiles - fiveKMiles) / fiveKMiles <= tolerance) {
                return '5km run';
            } else if (Math.abs(distanceInMiles - threeMiles) / threeMiles <= tolerance) {
                return '3 mile run';
            }

            return null;
        }

        function parseMyRaceResultFormat(line) {
            // Format: Place, Points, Name, Team, Bib, Pace, Time (tab or multi-space separated)
            // Example: "1    1    Marcelo MANTECON    Belen Jesuit Prep    5086    4:41    14:33"
            // Some entries have "--" for points (non-scoring runners)
            // Example: "13    --    Michael GIRARD    Viera    6490    4:58    15:26"

            const trimmed = line.trim();

            // Skip header lines and non-data lines
            if (!trimmed ||
                trimmed.match(/^(Place|Points|Name|Team|Bib|Pace|Time|Number of records)/i) ||
                trimmed.match(/^-+$/)) {
                return null;
            }

            // Split by tabs or multiple spaces
            const parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            if (parts.length < 7) return null;

            // Place - first column
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Points - second column (can be a number, "(number)" for non-varsity, or "--")
            const points = parts[1];
            // Validate it looks like points (number, parentheses, or dashes)
            if (!points.match(/^(\d+|\(\d+\)|--)$/)) return null;

            // Name - third column (format: "FirstName LASTNAME" or "FirstName MiddleName LASTNAME")
            const name = parts[2];
            if (!name || name.length === 0) return null;

            // Team - fourth column
            const team = parts[3];
            if (!team || team.length === 0) return null;

            // Bib - fifth column
            const bib = parts[4];
            if (!bib || !bib.match(/^\d{1,5}$/)) return null;

            // Pace - sixth column (format: M:SS)
            const pace = parts[5];
            if (!pace || !pace.match(/^\d{1,2}:\d{2}$/)) return null;

            // Time - seventh column (format: MM:SS)
            const time = parts[6];
            if (!time || !time.match(/^\d{1,2}:\d{2}$/)) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: '',
                points: points.match(/^\d+$/) ? points : '', // Only include numeric points
                pace: pace
            };
        }

        function parseAthleteGuildFormat(line) {
            // Format 1: "Name    Bib    Team    Rank    Chip Time    Pace"
            // Example: "Macee Rhodes    292    Utopia    1    14:24.429    11:35"
            // Format 2: "Name    Bib    Place    Time    Pace    Team"
            // Example: "Ella Morrison    114    1    12:42.950    6:21    Florence"

            // Split by tabs or multiple spaces (2+)
            const parts = line.trim().split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            if (parts.length < 5) return null;

            // First part should be a name (contains letters and possibly spaces)
            if (!parts[0].match(/^[A-Z][a-z]+(\s+[A-Z][a-z]+)+$/i)) return null;

            let partIndex = 0;

            // Name
            const name = parts[partIndex];
            partIndex++;

            // Bib number
            const bib = parts[partIndex];
            if (!bib.match(/^\d{1,4}$/)) return null;
            partIndex++;

            // Detect format by checking if next field is a number (place) or text (team)
            let place, team, time, pace;

            if (parts[partIndex].match(/^\d+$/)) {
                // Format 2: Name, Bib, Place, Time, Pace, Team
                place = parts[partIndex];
                partIndex++;

                // Time
                time = parts[partIndex];
                if (!time || !time.match(/\d+:\d+/)) return null;
                partIndex++;

                // Pace (optional)
                if (partIndex < parts.length && parts[partIndex].match(/^\d+:\d+$/)) {
                    pace = parts[partIndex];
                    partIndex++;
                }

                // Team (rest of the parts)
                team = parts.slice(partIndex).join(' ');
            } else {
                // Format 1: Name, Bib, Team, Rank, Time, Pace
                team = parts[partIndex];
                if (!team || team.length === 0) return null;
                partIndex++;

                // Rank (place)
                place = parts[partIndex];
                if (!place.match(/^\d+$/)) return null;
                partIndex++;

                // Chip Time
                time = parts[partIndex];
                if (!time || !time.match(/\d+:\d+/)) return null;
                partIndex++;

                // Pace (optional)
                if (partIndex < parts.length && parts[partIndex].match(/^\d+:\d+$/)) {
                    pace = parts[partIndex];
                }
            }

            // Round time to 2 decimal places if it has more
            const timeMatch = time.match(/^(\d+:\d+)\.(\d+)$/);
            if (timeMatch && timeMatch[2].length > 2) {
                const decimal = timeMatch[2].substring(0, 2);
                time = `${timeMatch[1]}.${decimal}`;
            }

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: '',
                points: '',
                pace: pace || ''
            };
        }

        function parseSpaceDelimitedFormat(line, nextLine) {
            // Format: "1 EMILY GROSS (DUMA) DUMAS, TX F: 1 SO 1596 00:11:27.55 05:43 10.5mph :"
            // Or multi-line:
            // "1 CHRISTIAN VALENZUELA MIDLAND, TX M: 1 JR 2818 00:17:26.91..."
            // "(MILE)"

            // Try single-line format first (team in parentheses on same line)
            let match = line.match(/^(\d+)\s+([A-Z\s]+)\s*\(([A-Z]{3,4})\)\s*(.+?)\s+([MF])R?:\s*\d+\s+(FR|SO|JR|SR|8th|\d{1,2}th)\s+(\d+)\s+([\d:\.]+)/i);

            if (match) {
                // Clean up time - remove leading "00:" if present
                let time = match[8].trim();
                if (time.startsWith('00:')) {
                    time = time.substring(3);
                }

                return {
                    place: match[1].trim(),
                    name: match[2].trim(),
                    team: match[3].trim(),
                    grade: match[6].trim().toUpperCase(),
                    bib: match[7].trim(),
                    time: time,
                    points: '',
                    pace: ''
                };
            }

            // Try multi-line format (team on next line)
            match = line.match(/^(\d+)\s+([A-Z\s]+)\s+(.+?)\s+([MF])R?:\s*\d+\s+(FR|SO|JR|SR|8th|\d{1,2}th)\s+(\d+)\s+([\d:\.]+)/i);

            if (match && nextLine) {
                const teamMatch = nextLine.match(/^\(([A-Z]{3,4})\)/i);
                if (teamMatch) {
                    // Clean up time - remove leading "00:" if present
                    let time = match[7].trim();
                    if (time.startsWith('00:')) {
                        time = time.substring(3);
                    }

                    return {
                        place: match[1].trim(),
                        name: match[2].trim(),
                        team: teamMatch[1].trim(),
                        grade: match[5].trim().toUpperCase(),
                        bib: match[6].trim(),
                        time: time,
                        points: '',
                        pace: ''
                    };
                }
            }

            return null;
        }

        function parseRunHighFormat(line) {
            // RunHigh format: "  ID#  POINTS  PLACE  Name, Grade  Split  Time  Pace  Team"
            // After trim: "1668     1     1  Gabe Simkiss, 11..."
            if (!line.match(/^\d{3,4}\s+/)) {
                return null;
            }
            
            let result = {
                place: '',
                points: '',
                bib: '',
                name: '',
                grade: '',
                team: '',
                time: '',
                pace: ''
            };
            
            // Split by multiple spaces (2 or more)
            const parts = line.trim().split(/\s{2,}/).map(p => p.trim()).filter(p => p);
            
            if (parts.length < 5) return null;
            
            let partIndex = 0;
            
            // ID# (bib number)
            if (partIndex < parts.length && parts[partIndex].match(/^\d{3,4}$/)) {
                result.bib = parts[partIndex];
                partIndex++;
            }
            
            // POINTS
            if (partIndex < parts.length && parts[partIndex].match(/^\d+$/)) {
                result.points = parts[partIndex];
                partIndex++;
            }
            
            // PLACE
            if (partIndex < parts.length && parts[partIndex].match(/^\d+$/)) {
                result.place = parts[partIndex];
                partIndex++;
            }
            
            // Name with grade - format "FirstName LastName, Grade" or "FirstName LastName, Grade*" (asterisk for females)
            if (partIndex < parts.length) {
                const namePart = parts[partIndex];
                const nameMatch = namePart.match(/^(.+),\s*(\d{1,2})\*?$/);
                if (nameMatch) {
                    result.name = nameMatch[1].trim();
                    result.grade = nameMatch[2];
                    partIndex++;
                } else {
                    result.name = namePart;
                    partIndex++;
                }
            }
            
            // Skip split time
            if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}:\d{2}\.\d+$/)) {
                partIndex++;
            }
            
            // Final time
            if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}:\d{2}\.\d+$/)) {
                result.time = parts[partIndex];
                partIndex++;
            }
            
            // Pace
            if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}:\d{2}$/)) {
                result.pace = parts[partIndex];
                partIndex++;
            }
            
            // Team name
            if (partIndex < parts.length) {
                result.team = parts.slice(partIndex).join(' ').trim();
            }
            
            return (result.place && result.name && result.time) ? result : null;
        }
        
        function parseKarmaRushTabFormat(lines, startIndex) {
            let i = startIndex;
            let result = {
                place: '',
                points: '',
                bib: '',
                name: '',
                grade: '',
                team: '',
                time: '',
                pace: ''
            };

            const firstLine = lines[i].trim();

            // Try splitting by tab first, then by any amount of spaces
            let tabParts = firstLine.split('\t').map(p => p.trim()).filter(p => p);

            // If no tab, try splitting by spaces (one or more)
            if (tabParts.length < 2) {
                // For space-delimited, we need to be careful: "1 Robert Mechura" should split into ["1", "Robert Mechura"]
                // Use a more careful approach: extract the first number, then take the rest as the name
                const match = firstLine.match(/^(\d+)\s+(.+)$/);
                if (match) {
                    tabParts = [match[1], match[2]];
                } else {
                    tabParts = [];
                }
            }

            // Check if place and name are on same line or separate lines
            if (tabParts.length >= 2) {
                // Place and name on same line: "1\tRobert Mechura" or "1    Robert Mechura"
                result.place = tabParts[0];
                result.name = tabParts[1];
                i++;
            } else if (tabParts.length === 1 && tabParts[0].match(/^\d+$/)) {
                // Place on its own line, name on next line
                result.place = tabParts[0];
                i++;
                if (i < lines.length) {
                    const nameLine = lines[i].trim();
                    // Skip if next line is also just a number (could be points)
                    if (!nameLine.match(/^\d+$/)) {
                        result.name = nameLine;
                        i++;
                    } else {
                        // If it's a number, this might not be the right pattern
                        return null;
                    }
                } else {
                    return null;
                }
            } else {
                return null;
            }
            
            if (i < lines.length) {
                const schoolLine = lines[i].trim();
                const match = schoolLine.match(/^(.+?)\s*\[(\d{1,2}|fr|so|jr|sr)\]\s*-\s*(\d+)$/i);
                if (match) {
                    result.team = match[1].trim();
                    result.grade = match[2];
                    result.bib = match[3];
                }
                i++;
            }
            
            if (i < lines.length && lines[i].match(/^\d{1,2}:\d{2}\.\d/)) {
                result.time = lines[i].trim();
                i++;
            }
            
            if (i < lines.length && lines[i].includes('|')) {
                i++;
            }
            
            let pointsCollected = 0;
            while (i < lines.length && pointsCollected < 2) {
                if (lines[i].trim().match(/^\d+$/)) {
                    if (!result.points) {
                        result.points = lines[i].trim();
                    }
                    i++;
                    pointsCollected++;
                } else {
                    break;
                }
            }
            
            return result.time ? { ...result, nextIndex: i } : null;
        }

        function parseMileSplitFormat(lines, startIndex) {
            let i = startIndex;
            let result = {
                place: '',
                points: '',
                bib: '',
                name: '',
                grade: '',
                team: '',
                time: '',
                pace: ''
            };
            
            const placeLine = lines[i].trim();
            if (!placeLine.match(/^(\d+|--)$/)) {
                return null;
            }
            
            result.place = placeLine;
            i++;
            
            if (i < lines.length && lines[i].trim().match(/^Logo/i)) {
                i++;
            }
            
            if (i < lines.length) {
                const nameLine = lines[i].trim();
                if (!nameLine.match(/^(\d+|--|Logo)$/i)) {
                    result.name = nameLine;
                    i++;
                } else {
                    return null;
                }
            }
            
            if (i < lines.length) {
                const teamLine = lines[i].trim();
                if (!teamLine.match(/^(\d+|--|Logo)$/i)) {
                    const bibMatch = teamLine.match(/#(\d+)/);
                    if (bibMatch) {
                        result.bib = bibMatch[1];
                        result.team = teamLine.replace(/-\s*#\d+/, '').trim();
                    } else {
                        result.team = teamLine;
                    }
                    i++;
                }
            }
            
            if (i < lines.length) {
                const timeLine = lines[i].trim();
                if (timeLine.match(/^\d{1,2}:\d{2}\.\d{1,2}$/) || timeLine === '--') {
                    result.time = timeLine;
                    i++;
                }
            }

            // Check for optional points field after time
            // Points field exists in some MileSplit formats but not in live results
            // If the line after time is a number, check what follows it:
            // - If followed by "Logo" or a name (letters), it's the next place number, not points
            // - Only treat as points if followed by something else (like a number or end of file)
            if (i < lines.length) {
                const nextLine = lines[i].trim();
                if ((nextLine.match(/^\d+$/) || nextLine === '--') && i + 1 < lines.length) {
                    const lookAhead = i + 1 < lines.length ? lines[i + 1].trim() : '';
                    // Don't treat as points if followed by Logo, a name, or another number
                    if (!lookAhead.match(/^Logo$/i) && !lookAhead.match(/^[A-Za-z]/)) {
                        result.points = nextLine;
                        i++;
                    }
                }
            }

            return result.name ? { ...result, nextIndex: i } : null;
        }

        function parseRunSignupFormat(lines, startIndex) {
            let i = startIndex;
            let result = {
                place: '',
                points: '',
                bib: '',
                name: '',
                grade: '',
                team: '',
                time: '',
                pace: ''
            };
            
            const placeLine = lines[i];
            const placeParts = placeLine.split(/\t/).filter(p => p);
            
            if (!placeParts[0] || !placeParts[0].match(/^\d+$/)) {
                return null;
            }
            
            result.place = placeParts[0];
            
            for (let j = 1; j < placeParts.length; j++) {
                const part = placeParts[j];
                if (part.match(/^\d+$/)) {
                    if (part.match(/^\d{3,4}$/) && !result.bib) {
                        result.bib = part;
                    } else if (!result.points) {
                        result.points = part;
                    }
                }
            }
            i++;
            
            if (i < lines.length && lines[i].match(/^[A-Z]$/)) {
                i++;
            }
            
            let firstName = '';
            let lastName = '';
            
            if (i < lines.length && lines[i].match(/^[A-Z][a-z]/)) {
                firstName = lines[i];
                i++;
            }
            
            if (i < lines.length && lines[i].match(/^[A-Z][a-z]/)) {
                lastName = lines[i];
                i++;
            }
            
            result.name = [firstName, lastName].filter(n => n).join(' ');
            
            if (i < lines.length && lines[i].includes('\t')) {
                const dataLine = lines[i];
                const parts = dataLine.split(/\t/).map(p => p.trim()).filter(p => p);
                
                let partIndex = 0;
                
                if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}$/)) {
                    const num = parseInt(parts[partIndex]);
                    if (num >= 7 && num <= 12) {
                        result.grade = parts[partIndex];
                        partIndex++;
                    }
                }
                
                let teamParts = [];
                while (partIndex < parts.length && !parts[partIndex].match(/^\d{1,2}:\d{2}/)) {
                    const part = parts[partIndex];
                    
                    if (!result.bib && part.match(/^\d{3,4}$/) && 
                        partIndex + 1 < parts.length && 
                        !parts[partIndex + 1].match(/^\d{1,2}:\d{2}/)) {
                        result.bib = part;
                    } else {
                        teamParts.push(part);
                    }
                    partIndex++;
                }
                
                let teamName = teamParts.join(' ');
                teamName = teamName.replace(/\s+\d+\s+\d+\s+\d+$/, '');
                teamName = teamName.replace(/\s+\d+\s+\d+$/, '');
                teamName = teamName.replace(/\s+\d+$/, '');
                teamName = teamName.replace(/\s*\([^)]*\)\s*$/, '');
                teamName = teamName.replace(/\s*<\s*\d+\s*Incomplete\s*\d*\s*$/, '');
                teamName = teamName.replace(/\s*<\s*\d+\s*$/, '');
                teamName = teamName.replace(/\s*>\s*\d*\s*$/, '');
                teamName = teamName.replace(/\s*>\s*$/, '');
                result.team = teamName.trim();
                
                if (partIndex < parts.length && parts[partIndex].match(/^\d{1,2}:\d{2}/)) {
                    result.time = parts[partIndex];
                }
                
                i++;
            }
            
            return result.name && result.time ? { ...result, nextIndex: i } : null;
        }

        function parseRaceResultFormat(line) {
            // Format: Place, Points, Bib (1-4 digits), Name, Team, Split1, Split2, Split3, Time, Pace
            // Example: "1    1    226    Maya Easterwood    Coppell    5:13    5:40    6:12    17:06    5:30 / mi"
            // Key: Bib comes BEFORE Name (distinguishes from MyRaceResult where bib comes after team)

            const trimmed = line.trim();

            // Skip non-data lines
            if (!trimmed || trimmed.match(/^(Place|Points|Bib|Name|Team|Time|Pace|Split|---+)/i)) {
                return null;
            }

            // Split by tabs or multiple spaces
            let parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            // Need at least: Place, Points, Bib, Name, Team, Time (6 fields minimum)
            // Typically 9-10 fields with splits and pace
            if (parts.length < 6) return null;

            // First part should be place number (may have trailing period: "1." or "1")
            let place = parts[0];
            if (!place.match(/^\d+\.?$/)) return null;
            // Remove trailing period if present
            place = place.replace(/\.$/, '');

            // Second part should be points (can be a number, "-", "~", "(n/s)", or "(number)")
            const points = parts[1];
            if (!points.match(/^(\d+|-|~|\(n\/s\)|\(\d+\))$/)) return null;

            // Third part should be bib (1-4 digits)
            const bib = parts[2];
            if (!bib.match(/^\d{1,4}$/)) return null;

            // Fourth part should be the name
            // Name could be "Maya Easterwood" (single field with first and last) or could span multiple fields
            const namePart = parts[3];
            if (!namePart || !namePart.match(/^[A-Z][a-z]/)) return null;

            // Find the main time field (should be near the end, format MM:SS or MM:SS.S)
            // Main race time is typically longer (15:00-25:00 range)
            let timeIndex = -1;
            for (let i = parts.length - 1; i >= 4; i--) {
                // Main race time format: MM:SS or MM:SS.S (no "/" character like in pace)
                if (parts[i].match(/^\d{2}:\d{2}(\.\d+)?$/) && !parts[i].includes('/')) {
                    const timeParts = parts[i].split(':');
                    const minutes = parseInt(timeParts[0]);
                    // Race times are typically 10+ minutes
                    if (minutes >= 10) {
                        timeIndex = i;
                        break;
                    }
                }
            }

            if (timeIndex === -1) return null;

            // Check if pace comes before time (format variation)
            // Pace format: M:SS or MM:SS (shorter times, 5-10 minute range)
            let paceIndex = -1;
            if (timeIndex > 4 && parts[timeIndex - 1].match(/^\d{1,2}:\d{2}$/)) {
                const potentialPaceParts = parts[timeIndex - 1].split(':');
                const minutes = parseInt(potentialPaceParts[0]);
                // Pace is typically 5-10 minutes per mile
                if (minutes >= 5 && minutes <= 12) {
                    paceIndex = timeIndex - 1;
                }
            }

            // Before pace/time, there might be grade and/or split times
            // Grade format: single digit (8, 9, 10, 11, 12) or "FR", "SO", "JR", "SR"
            let gradeIndex = -1;
            let searchStart = paceIndex !== -1 ? paceIndex - 1 : timeIndex - 1;

            if (searchStart >= 4 && parts[searchStart].match(/^(8|9|10|11|12|FR|SO|JR|SR)$/i)) {
                gradeIndex = searchStart;
                searchStart--;
            }

            // Before grade/pace/time, there might be 2-3 split times (format M:SS or MM:SS)
            let firstSplitIndex = searchStart;
            while (firstSplitIndex >= 4 && parts[firstSplitIndex].match(/^\d{1,2}:\d{2}$/)) {
                firstSplitIndex--;
            }

            // Everything from part 3 (name) to firstSplitIndex are name and team
            let name = parts[3];
            let team = '';

            if (firstSplitIndex >= 4) {
                // Team is from part 4 to firstSplitIndex (inclusive)
                team = parts.slice(4, firstSplitIndex + 1).join(' ');
            }

            const time = parts[timeIndex];

            // Extract grade if found
            let grade = '';
            if (gradeIndex !== -1) {
                grade = parts[gradeIndex];
            }

            // Extract pace
            let pace = '';
            if (paceIndex !== -1) {
                pace = parts[paceIndex];
            } else if (timeIndex + 1 < parts.length) {
                // Check if pace is after time (original format)
                const potentialPace = parts.slice(timeIndex + 1).join(' ');
                if (potentialPace.match(/\d{1,2}:\d{2}/)) {
                    pace = potentialPace;
                }
            }

            // Extract points value, removing parentheses if present
            let pointsValue = '';
            if (points && points !== '-' && points !== '~' && points !== '(n/s)') {
                // Remove parentheses if present: "(182)" -> "182"
                pointsValue = points.replace(/[()]/g, '');
            }

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: pointsValue,
                pace: pace
            };
        }

        function parseRiverCityFormat(line) {
            // Format: Place, Name (first last), Team (variable words), Bib (3-4 digits), Gender (M/F), Time
            // Example: "1 Carson Smith Air Academy High 1044 M 15:32.9"
            // Strategy: Parse from both ends - place from left, gender/time from right, find bib, rest is name and team

            const trimmed = line.trim();

            // Skip non-data lines
            if (!trimmed || trimmed.match(/^(Overall|Name|Team|Bib|Gender|Time|Gend|---+)/i)) {
                return null;
            }

            // Split by whitespace
            const parts = trimmed.split(/\s+/);

            // Need at least: Place, FirstName, LastName, Team, Bib, Gender, Time (7 fields minimum)
            if (parts.length < 7) return null;

            // First part should be place number
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Work backwards from the end
            // Last field should be time (MM:SS.S format)
            const time = parts[parts.length - 1];
            if (!time.match(/^\d{1,2}:\d{2}\.\d$/)) return null;

            // Second to last should be gender (M or F)
            const gender = parts[parts.length - 2];
            if (!gender.match(/^[MF]$/)) return null;

            // Third from last should be bib number (3-4 digits)
            const bib = parts[parts.length - 3];
            if (!bib.match(/^\d{3,4}$/)) return null;

            // Everything between place and bib is: FirstName, LastName, Team (variable words)
            // Strategy: First 2 words after place are name, rest is team
            if (parts.length - 4 < 3) return null; // Need at least first, last, and team

            const firstName = parts[1];
            const lastName = parts[2];
            const name = `${firstName} ${lastName}`;

            // Team is everything from index 3 to bib (parts.length - 4)
            const teamEndIndex = parts.length - 3;
            const team = parts.slice(3, teamEndIndex).join(' ');

            if (!team || team.length === 0) return null;

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: '',
                points: '',
                pace: ''
            };
        }

        function parseHyTekFormat(line) {
            // Format: Place, Name (Last, First), Grade, School/Team, Time, Points (optional)
            // Example: "1 Meyer, Josiah 10 Central Heights 17:23.10 1"
            // Example: "4 Alvarez, Myles 11 Pleasanton 17:53.39" (no points)
            // Header: "Name Year School Finals Points"
            // Also has "Results - Men" or "Results - Women" section headers

            const trimmed = line.trim();

            // Skip non-data lines, headers, separators, and team scores section
            if (!trimmed ||
                trimmed.match(/^(Event|\=+|Name|Year|School|Finals|Points|Results\s+-|Team\s+Scores|Rank\s+Team)/i) ||
                trimmed.match(/^Total Time:|^Average:/)) {
                return null;
            }

            // Split by whitespace
            const parts = trimmed.split(/\s+/);

            // Need at least: Place, LastName, FirstName, Grade, Team, Time (6 fields minimum)
            if (parts.length < 6) return null;

            // First part should be place number
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Second part should be last name with comma (LASTNAME,)
            if (!parts[1] || !parts[1].includes(',')) return null;

            // Extract name (format: "LastName, FirstName")
            const lastName = parts[1].replace(/,$/, '');
            const firstName = parts[2];
            const name = `${lastName}, ${firstName}`;

            // Grade should be next (9-12 for high school, or 6-8 for middle school)
            const grade = parts[3];
            if (!grade.match(/^([6-9]|1[0-2])$/)) return null;

            // Find the time field - it's in MM:SS.S or MM:SS.SS format
            let timeIndex = -1;
            for (let i = 4; i < parts.length; i++) {
                if (parts[i].match(/^\d{1,2}:\d{2}\.\d{1,2}$/)) {
                    timeIndex = i;
                    break;
                }
            }

            if (timeIndex === -1) return null;
            const time = parts[timeIndex];

            // Team is everything between grade and time
            const teamParts = parts.slice(4, timeIndex);
            if (teamParts.length === 0) return null;
            const team = teamParts.join(' ');

            // Points (if present) is after time
            let points = '';
            if (timeIndex + 1 < parts.length && parts[timeIndex + 1].match(/^\d+$/)) {
                points = parts[timeIndex + 1];
            }

            return {
                place: place,
                bib: '',
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: points,
                pace: ''
            };
        }

        function parseAthleticNetFormat(line) {
            // Format: Place, Name (First Last), Grade, Team, Time, Points (optional)
            // Example: "1 Anna Prusak 12 Hathaway Brown 18:05.59 1"
            // Example: "15 Tillie O'donnell 12 Will. South 20:02.07" (no points - non-scoring team)
            // Key: No bib numbers, grade after name, time in MM:SS.SS format

            const trimmed = line.trim();

            // Skip non-data lines, headers, and empty lines
            if (!trimmed ||
                trimmed.match(/^(PLACE|VIDEO|ATHLETE|TEAM|MARK|POINTS|---+)/i)) {
                return null;
            }

            // Split by whitespace
            const parts = trimmed.split(/\s+/);

            // Need at least: Place, FirstName, LastName, Grade, Team, Time (6 fields minimum)
            if (parts.length < 6) return null;

            // First part should be place number
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Second and third parts should be name (First Last)
            // Name should start with capital letter
            if (!parts[1] || !parts[1].match(/^[A-Z]/)) return null;
            if (!parts[2] || !parts[2].match(/^[A-Z]/)) return null;

            const firstName = parts[1];
            const lastName = parts[2];
            const name = `${firstName} ${lastName}`;

            // Fourth part should be grade (6-12)
            const grade = parts[3];
            if (!grade.match(/^([6-9]|1[0-2])$/)) return null;

            // Find the time field - it's in MM:SS.SS format
            let timeIndex = -1;
            for (let i = 4; i < parts.length; i++) {
                if (parts[i].match(/^\d{1,2}:\d{2}\.\d{1,2}$/)) {
                    timeIndex = i;
                    break;
                }
            }

            if (timeIndex === -1) return null;
            const time = parts[timeIndex];

            // Team is everything between grade and time
            const teamParts = parts.slice(4, timeIndex);
            if (teamParts.length === 0) return null;
            const team = teamParts.join(' ');

            // Points (if present) is after time
            let points = '';
            if (timeIndex + 1 < parts.length && parts[timeIndex + 1].match(/^\d+$/)) {
                points = parts[timeIndex + 1];
            }

            return {
                place: place,
                bib: '',
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: points,
                pace: ''
            };
        }

        function parseGoChipFormat(lines, startIndex) {
            // GoChip format is a multi-line format:
            // Line 1: Place (number, DNS, DNF, etc.)
            // Line 2: Name
            // Line 3+: One or more lap times (MM:SS.S format)
            // Last line: BibChip: CXXSchool
            // Example:
            // 1
            // Aiden Ready
            // 11:12.1
            // 23:17.1
            // 79Chip: C79Christian Homelearners Estreams

            let i = startIndex;
            let result = {
                place: '',
                bib: '',
                name: '',
                team: '',
                time: '',
                grade: '',
                points: '',
                pace: ''
            };

            // Line 1: Place
            const placeLine = lines[i]?.trim();
            if (!placeLine) return null;

            // Place can be a number, DNS, DNF, or other status
            if (placeLine.match(/^\d+$/) || placeLine.match(/^(DNS|DNF|DQ)$/i)) {
                result.place = placeLine;
                i++;
            } else {
                return null;
            }

            // Line 2: Name
            const nameLine = lines[i]?.trim();
            if (!nameLine || !nameLine.match(/^[A-Z]/i)) return null;
            result.name = nameLine;
            i++;

            // Lines 3+: Lap times (collect all times until we hit the "Chip:" line)
            const lapTimes = [];
            while (i < lines.length) {
                const line = lines[i].trim();

                // Check if this is the info line with bib/chip/team
                if (line.match(/^\d+Chip:\s*[CE]/i)) {
                    // Parse the info line: "79Chip: C79Christian Homelearners Estreams"
                    const match = line.match(/^(\d+)Chip:\s*([CE]\d+)(.*)$/i);
                    if (match) {
                        result.bib = match[1];
                        // Chip ID is match[2], but we don't have a field for it
                        result.team = match[3].trim();
                    }
                    i++;
                    break;
                }

                // Check if this is a lap time
                if (line.match(/^\d{1,2}:\d{2}\.\d+$/)) {
                    lapTimes.push(line);
                    i++;
                } else {
                    // Not a time and not the info line, stop parsing
                    break;
                }
            }

            // The final time is the last lap time
            if (lapTimes.length > 0) {
                result.time = lapTimes[lapTimes.length - 1];
            }

            // Only return if we have at least place, name, and time
            if (result.place && result.name && result.time) {
                return {
                    ...result,
                    nextIndex: i
                };
            }

            return null;
        }

        function parseRMSFormat(line) {
            // Race Management Systems (RMS) format
            // Pattern: Place Score Bib No Name Team Grade Time Pace [Class] [Qualifier]
            // Example: "1 1 684 Cooper Ratliff Mason 11 17:13.64 5:33/M TM"
            // Example: "3 (< 5) 247 Colton Vrazel Danbury 12 17:17.93 5:35/M IND"
            // Example: "6 5 682 Caden Klingelhefer Mason 11 18:01.25 5:49/M TM"
            // Example: "8 (< 5) 403 Ty Szymanski Ganado 18:08.30 5:51/M IND"
            // Score can be: number, "(< 5)", or other variations
            // Grade can be: 9, 10, 11, 12, Fr, So, or blank
            // Last columns may have "TM" (team) or "IND" (individual) markers

            const trimmed = line.trim();

            // Skip non-data lines
            if (!trimmed || trimmed.match(/^(Place|Score|Bib|No|Name|Team|Grade|Time|Pace|Class|Qualifier|---+|Results By)/i)) {
                return null;
            }

            // Split by multiple spaces (typically 2+)
            let parts = trimmed.split(/\s{2,}/).map(p => p.trim()).filter(p => p);

            // If we don't have enough parts with multi-space delimiter, try splitting by single spaces
            // This handles cases where some columns run together
            if (parts.length < 7) {
                parts = trimmed.split(/\s+/);
            }

            // Need at least: Place, Score, Bib, Name (First Last), Team, Grade, Time, Pace (8+ fields)
            if (parts.length < 8) return null;

            // First part should be place number
            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Second part is score (can be number or "(< 5)" or other variations)
            let score = parts[1];
            let scoreIndex = 1;

            // Handle multi-word score like "( < 5 )" by combining parts
            if (score === '(' || score.startsWith('(')) {
                let combined = score;
                let combineIndex = scoreIndex + 1;
                // Combine until we find closing paren
                while (combineIndex < parts.length && !combined.includes(')')) {
                    combined += ' ' + parts[combineIndex];
                    combineIndex++;
                }
                if (combined.includes(')')) {
                    score = combined.replace(/\s+/g, ''); // Remove internal spaces
                    // Adjust parts array
                    parts = [parts[0], score, ...parts.slice(combineIndex)];
                }
            }

            // Third part should be bib (3-4 digits typically)
            const bib = parts[2];
            if (!bib.match(/^\d{1,4}$/)) return null;

            // Find the time - it's in format MM:SS.SS and occurs before the pace
            // Pace is in format M:SS/M
            let timeIndex = -1;
            let paceIndex = -1;

            // Search from the end for pace (has /M)
            for (let i = parts.length - 1; i >= 3; i--) {
                if (parts[i].match(/^\d{1,2}:\d{2}\/M$/i)) {
                    paceIndex = i;
                    break;
                }
            }

            // Time is right before pace (or search for it if no pace found)
            if (paceIndex !== -1) {
                timeIndex = paceIndex - 1;
            } else {
                // No pace found, look for time format MM:SS.SS
                for (let i = parts.length - 1; i >= 3; i--) {
                    if (parts[i].match(/^\d{1,2}:\d{2}\.\d+$/)) {
                        timeIndex = i;
                        break;
                    }
                }
            }

            if (timeIndex === -1) return null;

            const time = parts[timeIndex];
            const pace = paceIndex !== -1 ? parts[paceIndex] : '';

            // Grade is right before time
            // Grade can be: 9, 10, 11, 12, Fr, So, Jr, Sr, or missing
            let gradeIndex = timeIndex - 1;
            let grade = '';

            if (gradeIndex >= 3 && parts[gradeIndex].match(/^([6-9]|1[0-2]|Fr|So|Jr|Sr)$/i)) {
                grade = parts[gradeIndex];
            } else {
                // No grade, so grade index moves up
                gradeIndex = timeIndex; // Adjust for missing grade
            }

            // Name is parts[3] and parts[4] (First Last)
            // Team is everything between name and grade
            let nameParts = [];
            let teamStartIndex = 3;

            // Name is typically 2 parts (first and last name)
            if (parts[3] && parts[3].match(/^[A-Z][a-z]/)) {
                nameParts.push(parts[3]);
                if (parts[4] && parts[4].match(/^[A-Z][a-z]/)) {
                    nameParts.push(parts[4]);
                    teamStartIndex = 5;
                } else {
                    teamStartIndex = 4;
                }
            } else {
                return null;
            }

            const name = nameParts.join(' ');

            // Team is everything between name end and grade
            let teamParts = [];
            for (let i = teamStartIndex; i < gradeIndex; i++) {
                // Skip TM and IND markers
                if (parts[i] !== 'TM' && parts[i] !== 'IND') {
                    teamParts.push(parts[i]);
                }
            }

            const team = teamParts.join(' ');

            // Extract score value
            let scoreValue = '';
            if (score && score.match(/\d+/)) {
                // Extract the number from patterns like "(< 5)" or "1"
                const scoreMatch = score.match(/\d+/);
                if (scoreMatch && !score.includes('<') && !score.includes('>')) {
                    scoreValue = scoreMatch[0];
                }
            }

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: scoreValue,
                pace: pace
            };
        }

        function parseBCFormat(line) {
            // BC Athletics format (British Columbia championships)
            // Pattern: OverallPlace, TeamPlace    Time Name, First              Team
            // Example: "  1,  1      13:30.4 Baker, Caleb                   Elgin Park Secondary"
            // Example: "  7,         14:27.5 Kaila, Shae                    Lord Tweedsmuir Secondary"
            // Example: " 10,  8      22:05.6 Young, Isla                    White Rock Christian Academy"
            // Fixed-width format:
            //   - Columns 1-3: Overall place (right-aligned)
            //   - Column 4: Comma
            //   - Columns 5-8: Team place/score (may be blank for non-scoring)
            //   - Columns 9+: Time (variable position)
            //   - After time: Name in "Last, First" format
            //   - After name: Team name (padded to right)

            const trimmed = line.trim();

            // Skip non-data lines
            if (!trimmed ||
                trimmed.match(/^(Individual|Results|Team|Scores|Boys?|Girls?|Run|CC|Championship|_+|<pre>|<\/pre>)/i) ||
                trimmed.length < 20) {
                return null;
            }

            // Pattern: starts with optional spaces, number, comma, optional spaces/number, time
            // Time format: MM:SS.S or M:SS.S
            // Note: Team place must be followed by space(s), OR there's just spaces before time
            // Use lookahead to ensure team place (if present) is followed by space
            const match = line.match(/^(\s*)(\d+),\s+(?:(\d+)\s+)?\s*(\d{1,2}:\d{2}\.\d+)\s+(.+)$/);

            if (!match) {
                console.log('BC format: No match for line:', line.substring(0, 80));
                return null;
            }

            const place = match[2].trim();
            const teamPlace = match[3] ? match[3].trim() : ''; // May be empty for non-scoring runners
            const time = match[4];
            const rest = match[5]; // Contains name and team

            // Parse name and team from the rest
            // Name is in "Last, First" format followed by team
            // Example: "Baker, Caleb                   Elgin Park Secondary"
            // Example: "moon, brandon                  Grandview Heights Secondary" (lowercase last name)
            // Example: "Wang, George (Zhe)             White Rock Christian Academy" (parentheses)
            // Be flexible with casing and handle multi-word names
            const nameMatch = rest.match(/^([A-Za-z][A-Za-z\s-]+?),\s+([A-Za-z]+(?:\s+\([A-Za-z0-9\s]+\))?)\s{2,}(.+)$/);

            if (!nameMatch) {
                console.log('BC format: Name parse failed for rest:', rest.substring(0, 60));
                return null;
            }

            const lastName = nameMatch[1].trim();
            const firstName = nameMatch[2].trim();
            const team = nameMatch[3].trim();

            const name = `${firstName} ${lastName}`;

            return {
                place: place,
                bib: '',
                name: name,
                team: team,
                time: time,
                grade: '',
                points: teamPlace, // Use team place as points
                pace: ''
            };
        }

        function parseColoradoFormat(line) {
            // Colorado format (appears to be Colorado high school cross country)
            // Pattern: Place Name (TEAM) Grade Time
            // Example: "1            RILEY COLE (CHEYENNE MOUNTAIN HIG)                    SR            00:18:07.63"
            // Example: "202            GIOVONNI HENRY (SAND CREEK HIGH SCHOOL)                    SO            00:35:34.27"
            // Fixed-width format with:
            //   - Place number (left-aligned, variable width)
            //   - Name in ALL CAPS (FIRST LAST or FIRST MIDDLE LAST format)
            //   - Team/school in parentheses (abbreviated)
            //   - Grade (FR/SO/JR/SR)
            //   - Time (HH:MM:SS.SS format with leading zeros)

            const trimmed = line.trim();

            // Skip non-data lines
            if (!trimmed || trimmed.length < 30) {
                return null;
            }

            // Pattern: Place, Name (ALL CAPS), Team in parens, Grade, Time
            // Use a more flexible regex that handles variable spacing and tabs
            const match = line.match(/^(\d+)[\s\t]+([A-Z][A-Z\s'-]+?)\s*\(([^)]+)\)[\s\t]+(FR|SO|JR|SR)[\s\t]+(\d{2}:\d{2}:\d{2}\.\d{2})\s*$/);

            if (!match) return null;

            const place = match[1].trim();
            const name = match[2].trim(); // Already in FIRST LAST format, all caps
            const team = match[3].trim();
            const grade = match[4];
            let time = match[5];

            // Remove leading "00:" from times (convert HH:MM:SS to MM:SS)
            if (time.startsWith('00:')) {
                time = time.substring(3);
            }

            // Convert ALL CAPS name to Title Case for better readability
            const nameParts = name.split(/\s+/);
            const titleCaseName = nameParts.map(part => {
                // Handle hyphenated names
                if (part.includes('-')) {
                    return part.split('-').map(p =>
                        p.charAt(0).toUpperCase() + p.slice(1).toLowerCase()
                    ).join('-');
                }
                return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
            }).join(' ');

            return {
                place: place,
                bib: '',
                name: titleCaseName,
                team: team,
                time: time,
                grade: grade,
                points: '',
                pace: ''
            };
        }

        function detectPlatform(text) {
            const lowerText = text.toLowerCase();

            // Check for Team Scores format (MileSplit team scores - not individual results)
            if (lowerText.includes('team scores') &&
                text.match(/Place\s+Team\s+Points/i) &&
                text.match(/\d+\s+\+.*1-5 Split/)) {
                return 'MileSplit Team Scores';
            }

            // Check for Colorado format
            // Key identifiers: ALL CAPS names, team in parentheses, FR/SO/JR/SR grade, HH:MM:SS.SS time
            // Example: "1            RILEY COLE (CHEYENNE MOUNTAIN HIG)                    SR            00:18:07.63"
            // Can be tab-delimited: "1\t\t\tRILEY COLE (CHEYENNE MOUNTAIN HIG)\t\t\t\t\tSR\t\t\t00:18:07.63"
            if (text.match(/^\d+[\s\t]+[A-Z][A-Z\s'-]+\s*\([^)]+\)[\s\t]+(FR|SO|JR|SR)[\s\t]+\d{2}:\d{2}:\d{2}\.\d{2}/m)) {
                return 'Colorado';
            }

            // Check for BC Athletics format (British Columbia)
            // Key identifiers: "Individual Results" header
            //                  Lines with pattern: number, comma, optional number, time, name (Last, First)
            //                  Event names like "Boys 4k Run CC Junior 4000m"
            if (lowerText.includes('individual results') &&
                text.match(/^\s*\d+,\s+\d*\s+\d{1,2}:\d{2}\.\d+\s+[A-Z][a-z]+,\s+[A-Z]/m) &&
                text.match(/(Boys?|Girls?)\s+\d+k?\s+(Run|Meter Run)\s+CC/i)) {
                return 'BC Athletics';
            }

            // Check for Race Management Systems (RMS) format
            // Key identifiers: "Results By Race Management Systems, Inc." footer
            //                  "Overall Finish List" header
            //                  Pace format with /M suffix (e.g., "5:33/M")
            if (lowerText.includes('results by race management systems') ||
                (lowerText.includes('overall finish list') && text.match(/\d{1,2}:\d{2}\/M/i))) {
                return 'Race Management Systems (RMS)';
            }

            // Check for Competitive Timing format: Has "Team Finish List"
            if (lowerText.includes('team finish list') && text.match(/^1(\t|\s{2,})\d{3,5}(\t|\s{2,})[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d{1,2}(\t|\s{2,})[A-Z][\w\s]+(\t|\s{2,})(\d+|<\s*\d+|>\s*\d+|\(\d+\))/m)) return 'Competitive Timing';

            // Check for Race Roster format: Has "Individuals" and bib at start
            if (lowerText.includes('individuals') && text.match(/^\d{1,4}(\t|\s{2,})[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d+(\t|\s{2,})[A-Z\s]+(\t|\s{2,})(FR|SO|JR|SR)/m)) return 'Race Roster';

            // Check for MyRaceResult format: Place, Points, Name, Team, Bib, Pace, Time
            if (text.match(/^1(\t|\s{2,})\d+(\t|\s{2,})[A-Z][a-z]+\s+[A-Z]+(\t|\s{2,})[\w\s]+(\t|\s{2,})\d{3,5}(\t|\s{2,})\d{1,2}:\d{2}(\t|\s{2,})\d{1,2}:\d{2}/m)) return 'MyRaceResult';

            // Check for HyTek format: Has Event headers or Name/Year/School/Finals header pattern
            // Must check BEFORE MeetPro since both use LASTNAME, Firstname but HyTek has specific headers
            if ((text.match(/^Event\s+\d+\s+(Boys?|Girls?|Men|Women)/mi) && text.match(/Name\s+Year\s+School/i)) ||
                (text.match(/Name\s+Year\s+School\s+Finals/i) && text.match(/^\d+\s+[A-Z][a-z]+,\s+[A-Z][a-z]+\s+(9|10|11|12)\s+/m))) {
                return 'HyTek';
            }

            // Check for MeetPro first (has "Race #X" pattern)
            if (text.match(/Race\s+#\d+/i)) return 'MeetPro';

            // Check for LASTNAME, Firstname format (also MeetPro)
            if (text.match(/^\d+\s+[A-Z]+,\s+[A-Z]/m)) return 'MeetPro';

            if (lowerText.includes('karmarush')) return 'KarmaRush';
            if (lowerText.includes('milesplit') || text.includes('Logo')) return 'MileSplit';
            if (lowerText.includes('runsignup')) return 'RunSignup';
            if (lowerText.includes('runhigh') || text.match(/ID#\s+POINTS\s+FINISHER/)) return 'RunHigh';
            if (lowerText.includes('athlete guild') || lowerText.includes('athleteguild')) return 'Athlete Guild';
            if (lowerText.includes('vfp') || lowerText.includes('v fit productions')) return 'VFP';
            if (lowerText.includes('rcc timing')) return 'RCC Timing';

            // Check for GoChip format: Multi-line with "Chip: CXX" or "Chip: EXX"
            // Example: "79Chip: C79Christian Homelearners Estreams"
            if (text.match(/\d+Chip:\s*[CE]\d+/i)) return 'GoChip';

            // Check for RCC Timing format: Overall, Score, Bib, Name, Class (SR/JR/SO/FR), Time, Team
            if (text.match(/(SR|JR|SO|FR)\s+\d{2}:\d{2}:\d{2}\.\d/m) && text.match(/^1\s+/m)) return 'RCC Timing';

            // Check for Web Timer format: Position, Bib, Name, Time (00:HH:MM.S)
            if (text.match(/^1\s+\d{2,5}\s+\w+.*\d{2}:\d{2}:\d{2}\.\d/m)) return 'Web Timer';

            // Check for VFP format: Place    Score    Bib    Name    Team    Grade    Time
            if (text.match(/^1(\t|\s{2,})(\(.*\)|\d+)(\t|\s{2,})\d{2,4}(\t|\s{2,})[A-Z]/m)) return 'VFP';

            // Check for Athlete Guild format: Name    Bib    Team    Rank    Time
            if (text.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(\t|\s{2,})\d{2,4}(\t|\s{2,})[A-Z]/m)) return 'Athlete Guild';

            // Check for Endurance Splits format before other patterns
            if (text.match(/^\d+(\t|\s{2,})\d+(\t|\s{2,})\d{3,4}(\t|\s{2,})[A-Z]/m)) return 'Endurance Splits';

            if (text.match(/^\s+\d{3,4}\s+\d+\s+\d+\s+[A-Z][a-z]+.*,\s*\d{1,2}\s+\d{1,2}:\d{2}\.\d+/m)) return 'RunHigh';
            if (text.match(/\[\d{1,2}\] - \d{3,4}/)) return 'KarmaRush';
            if (text.match(/^\d{1,3}\s{2,}\d{2,4}\s{2,}/m)) return 'PDF';
            if (text.match(/\t.*\t.*\d{1,2}:\d{2}\.\d/)) return 'RunSignup';

            return 'Auto-detected';
        }

        function displayResults() {
            const tbody = document.getElementById('tableBody');
            
            if (extractedResults.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" class="empty-state">
                            <div class="empty-state-icon">üìã</div>
                            <div>No results yet. Paste race data above and click "Extract Results"</div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = extractedResults.map((r, index) => {
                // Check if this is a header row
                if (r.isHeader) {
                    return `
                        <tr class="race-header-row">
                            <td colspan="6" class="race-header">${r.headerText}</td>
                        </tr>
                    `;
                }

                let placeClass = 'place-cell';
                if (r.place === '1') placeClass += ' gold';
                else if (r.place === '2') placeClass += ' silver';
                else if (r.place === '3') placeClass += ' bronze';

                return `
                    <tr>
                        <td class="${placeClass}">${r.place}</td>
                        <td class="bib-cell">${r.bib}</td>
                        <td class="name-cell">${r.name}</td>
                        <td style="text-align: center;">${r.grade}</td>
                        <td class="team-cell">${r.team}</td>
                        <td class="time-cell">${r.time}</td>
                    </tr>
                `;
            }).join('');
        }

        function displayTeamScores() {
            const output = document.getElementById('teamScoresOutput');

            if (extractedResults.length === 0) {
                output.textContent = 'No team scores yet. Paste team scores data above and click "Extract Results"';
                return;
            }

            // Fixed column widths matching: "PLACE  TEAM               POINTS"
            const PLACE_WIDTH = 5;   // "PLACE" = 5 chars
            const TEAM_WIDTH = 19;   // "TEAM               " = 19 chars (including trailing spaces)

            // Build formatted output with fixed column alignment
            let lines = [];

            // Format each row
            extractedResults.forEach(r => {
                if (r.isHeader) {
                    // For headers, use fixed spacing (2 spaces between columns)
                    if (r.headerText.includes('\t')) {
                        // This is the column header (PLACE\tTEAM\tPOINTS)
                        const parts = r.headerText.split('\t');
                        const line = parts[0].padEnd(PLACE_WIDTH) + '  ' +
                                   parts[1].padEnd(TEAM_WIDTH) + '  ' + parts[2];
                        lines.push(line);
                    } else {
                        // Race name header
                        lines.push(r.headerText);
                    }
                } else {
                    // Data row: fixed column widths, truncate team name if needed
                    const place = (r.place || '').padEnd(PLACE_WIDTH);
                    let team = r.team || '';
                    // Truncate team name if longer than TEAM_WIDTH to ensure 2 spaces before points
                    if (team.length > TEAM_WIDTH) {
                        team = team.substring(0, TEAM_WIDTH);
                    }
                    team = team.padEnd(TEAM_WIDTH);
                    const points = r.time || '';
                    lines.push(`${place}  ${team}  ${points}`);
                }
            });

            output.textContent = lines.join('\n');
        }

        function copyTeamScores() {
            const output = document.getElementById('teamScoresOutput').textContent;
            if (!output || output.includes('No team scores')) {
                showToast('No team scores to copy');
                return;
            }
            copyToClipboard(output);
            showToast('Team scores copied to clipboard!');
        }

        function copyAsSpreadsheet() {
            if (extractedResults.length === 0) {
                showToast('No results to copy');
                return;
            }

            const delimiter = document.getElementById('delimiter').value === 'csv' ? ',' :
                            document.getElementById('delimiter').value === 'pipe' ? '|' : '\t';

            // Check if this is team scores data (no bib/name/grade in first data row)
            const firstDataRow = extractedResults.find(r => !r.isHeader);
            const isTeamScores = firstDataRow && !firstDataRow.bib && !firstDataRow.name && !firstDataRow.grade;

            const rows = extractedResults.map(r => {
                // If it's a header row, output the header text as-is (may have tabs embedded)
                if (r.isHeader) {
                    return r.headerText;
                }
                // For team scores (no bib, name, or grade), output only place, team, and points
                if (!r.bib && !r.name && !r.grade && r.place && r.team && r.time) {
                    return [r.place, r.team, r.time].join('\t');
                }
                return [r.place, r.bib, r.name, r.grade, r.team, r.time].join(delimiter);
            });

            // Only add generic header if it's NOT team scores (team scores have their own header)
            const output = isTeamScores ? rows.join('\n') : [['Place', 'Bib', 'Name', 'Grade', 'Team', 'Time'].join(delimiter), ...rows].join('\n');
            
            copyToClipboard(output);
            showToast('Copied to clipboard!');
        }

        function copyTableData() {
            if (extractedResults.length === 0) {
                showToast('No results to copy');
                return;
            }

            const delimiter = '\t';

            // Check if this is team scores data (no bib/name/grade in first data row)
            const firstDataRow = extractedResults.find(r => !r.isHeader);
            const isTeamScores = firstDataRow && !firstDataRow.bib && !firstDataRow.name && !firstDataRow.grade;

            const rows = extractedResults.map(r => {
                // If it's a header row, output the header text as-is (may have tabs embedded)
                if (r.isHeader) {
                    return r.headerText;
                }
                // For team scores (no bib, name, or grade), output only place, team, and points
                if (!r.bib && !r.name && !r.grade && r.place && r.team && r.time) {
                    return [r.place, r.team, r.time].join('\t');
                }
                return [r.place, r.bib, r.name, r.grade, r.team, r.time].join(delimiter);
            });

            // Only add generic header if it's NOT team scores (team scores have their own header)
            const output = isTeamScores ? rows.join('\n') : [['Place', 'Bib', 'Name', 'Grade', 'Team', 'Time'].join(delimiter), ...rows].join('\n');
            
            copyToClipboard(output);
            showToast('Table copied to clipboard!');
        }

        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }

        function clearAll() {
            document.getElementById('input').value = '';
            extractedResults = [];
            displayResults();
            document.getElementById('rowCount').textContent = '0';
            document.getElementById('platform').textContent = '-';
            document.getElementById('status').textContent = 'Ready';
            showToast('Cleared all data');
        }

        function loadSample() {
            const sampleData = `  ID#  POINTS        FINISHER          TIME       2.5K    
 1668     1     1  Gabe Simkiss, 11          8:11.2   16:13.7    5:14  Regina Luminis Acad.     
  509     2     2  Kendel Jones, 12          8:10.5   16:17.8    5:15  Elk Lake                 
  503     3     3  Cody Adams, 12            8:15.3   16:40.1    5:23  Elk Lake                 
 1720     4     4  Mikey Schimelfenig, 12    8:15.3   16:53.7    5:27  Riverside                
  512     5     5  Parker Upright, 11        8:19.1   16:58.5    5:29  Elk Lake`;
            
            document.getElementById('input').value = sampleData;
            showToast('Sample data loaded - click Extract Results');
        }
    </script>
</body>
</html>