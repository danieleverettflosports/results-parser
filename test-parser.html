<!DOCTYPE html>
<html>
<head>
    <title>MeetPro Parser Test</title>
</head>
<body>
    <h1>MeetPro Parser Test</h1>
    <pre id="output"></pre>

    <script>
        function parseMeetProFormat(line) {
            // Format: Place, Name (LAST, First), Yr., #, Team, Score, Time, Gap, Avg. Mile, Avg. kM
            // Example: "1    ESEVERRI, Diego    SR    568    Columbus    1    15:30.6    ---    4:59.2"
            // Example: "2    GARGANO, Massimo    SR    567    Columbus    2    15:46.1    15.5    5:04.2"
            // Example: "1    MYERS, Colton    8    3006    Trinity    1    11:35.5    ---    5:47/M"
            // Example with no grade: "2    LEFKO, Noah        3275    WIND Runners    1    10:15.7    16.7    5:31.0"
            // Example with no gap: "1    FERNLUND, Philip    FR    1568    Oviedo    1    18:50.0    6:03.3"
            // Example with single spaces: "25 MARTINEZ, Alek FR 1333 Hialeah Educational - 22:23.5 3:58.6 7:12.0 4:28.7"
            // Example with parentheses in score: "37 BRYCE, Ian 7 406 Calvary Christian (F (27) 23:17.8 4:52.9 7:29.5 4:39.6"

            const trimmed = line.trim();

            // Skip non-data lines
            if (!trimmed || trimmed.match(/^(Place|Athlete|Individual|Team|---+|\d+\)|Yr\.|#|Score|Time|Gap|Avg)/i)) {
                return null;
            }

            // Try splitting by tabs or multiple spaces first
            let parts = trimmed.split(/\t|\s{2,}/).map(p => p.trim()).filter(p => p);

            // If we only got 1-2 parts, this is likely single-space delimited
            // Parse it differently by working from both ends
            if (parts.length < 6) {
                parts = trimmed.split(/\s+/);

                if (parts.length < 6) return null;

                // Parse from left: Place, Name (LAST, First), [Grade], Bib
                const place = parts[0];
                if (!place.match(/^\d+$/)) return null;

                // Find the name (LAST, First format)
                let nameEndIndex = -1;
                for (let i = 1; i < parts.length - 4; i++) {
                    if (parts[i].includes(',')) {
                        // Check if next part looks like the rest of the name or a grade/bib
                        if (i + 1 < parts.length && !parts[i + 1].match(/^(FR|SO|JR|SR|[6-8]|\d{3,})$/i)) {
                            // Multi-word name, combine this and next part
                            nameEndIndex = i + 1;
                        } else {
                            nameEndIndex = i;
                        }
                        break;
                    }
                }

                if (nameEndIndex === -1) return null;

                const name = parts.slice(1, nameEndIndex + 1).join(' ');
                if (!name.includes(',')) return null;

                // Next is either grade or bib
                let currentIndex = nameEndIndex + 1;
                let grade = '';

                if (currentIndex < parts.length && parts[currentIndex].match(/^(FR|SO|JR|SR|[6-8])$/i)) {
                    grade = parts[currentIndex].toUpperCase();
                    currentIndex++;
                }

                // Bib number
                if (currentIndex >= parts.length) return null;
                const bib = parts[currentIndex];
                if (!bib.match(/^\d+$/)) return null;
                currentIndex++;

                // Now work backwards from the end to find time
                // Format from right: [Avg.kM] [Avg.Mile] Gap Time Score Team...
                // Time is always in MM:SS.S format
                let timeIndex = -1;
                for (let i = parts.length - 1; i >= currentIndex; i--) {
                    if (parts[i].match(/^\d{1,2}:\d{2}\.\d/)) {
                        timeIndex = i;
                        break;
                    }
                }

                if (timeIndex === -1) return null;
                const time = parts[timeIndex];

                // Score is right before time (can be number, "-", or "(number)")
                if (timeIndex - 1 < currentIndex) return null;
                let scoreIndex = timeIndex - 1;
                let score = parts[scoreIndex];

                // Handle scores in parentheses like "(27)"
                if (score.match(/^\(\d+\)$/)) {
                    score = score.replace(/[()]/g, '');
                } else if (score === '-') {
                    score = '';
                }

                // Team is everything between bib and score
                if (scoreIndex <= currentIndex) return null;
                const team = parts.slice(currentIndex, scoreIndex).join(' ');

                if (!team || team.length === 0) return null;

                return {
                    place: place,
                    bib: bib,
                    name: name,
                    team: team,
                    time: time,
                    grade: grade,
                    points: score.match(/^\d+$/) ? score : '',
                    pace: ''
                };
            }

            // Original tab/multi-space delimited parsing
            // Need at least: Place, Name, Bib, Team, Score, Time (6 fields minimum if no grade/gap/pace)
            // Could have up to 9 fields: Place, Name, Grade, Bib, Team, Score, Time, Gap, Pace
            if (parts.length < 6) return null;

            const place = parts[0];
            if (!place.match(/^\d+$/)) return null;

            // Name is in format "LAST, First" or "LAST, First Middle"
            const name = parts[1];
            if (!name || !name.includes(',')) return null;

            // Check if parts[2] is a grade (FR, SO, JR, SR, or 6-8) or a bib number
            let grade = '';
            let bibIndex = 2;

            if (parts[2] && parts[2].match(/^(FR|SO|JR|SR|[6-8])$/i)) {
                // Grade is present
                grade = parts[2].toUpperCase();
                bibIndex = 3;
            }
            // else: No grade, bibIndex stays at 2

            // Bib number
            const bib = parts[bibIndex];
            if (!bib || !bib.match(/^\d+$/)) return null;

            // Team name
            const team = parts[bibIndex + 1];
            if (!team || team.length === 0) return null;

            // Score (can be a number or "--" or other markers)
            const score = parts[bibIndex + 2];

            // Time (MM:SS.S format)
            const time = parts[bibIndex + 3];
            if (!time || !time.match(/^\d{1,2}:\d{2}\.\d/)) return null;

            // Gap is parts[bibIndex + 4] - we ignore it
            // Avg. Mile/Pace is parts[bibIndex + 5] - optional

            return {
                place: place,
                bib: bib,
                name: name,
                team: team,
                time: time,
                grade: grade,
                points: score && score.match(/^\d+$/) ? score : '',
                pace: ''
            };
        }

        // Test cases
        const testLines = [
            "25 MARTINEZ, Alek FR 1333 Hialeah Educational - 22:23.5 3:58.6 7:12.0 4:28.7",
            "26 NOMBRE, Andrew 6 181 Atlantic Christian - 22:26.6 4:01.7 7:13.0 4:29.3",
            "27 SAVYSKY, Grayson SO 1859 Miami Country Day 18 22:27.9 4:03.0 7:13.4 4:29.6",
            "28 KIRWIN, Finn JR 1442 John Carroll 19 22:37.4 4:12.5 7:16.4 4:31.5",
            "37 BRYCE, Ian 7 406 Calvary Christian (F (27) 23:17.8 4:52.9 7:29.5 4:39.6",
            "38 MACKI, Ethan FR 421 Calvary Christian (F (28) 23:35.7 5:10.8 7:35.2 4:43.1",
            "75 FONTALVO, Andre FR 339 Boca Raton Christia 54 25:28.6 7:03.7 8:11.5 5:05.7"
        ];

        let output = "Testing MeetPro Parser:\n\n";

        testLines.forEach(line => {
            output += `Input: ${line}\n`;
            const result = parseMeetProFormat(line);
            if (result) {
                output += `  ✓ Parsed successfully:\n`;
                output += `    Place: ${result.place}, Name: ${result.name}, Grade: ${result.grade || 'N/A'}\n`;
                output += `    Bib: ${result.bib}, Team: ${result.team}, Time: ${result.time}, Points: ${result.points || 'N/A'}\n`;
            } else {
                output += `  ✗ Failed to parse\n`;
            }
            output += '\n';
        });

        document.getElementById('output').textContent = output;
    </script>
</body>
</html>
